/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD;
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/styles.ts
var MODAL_STYLES, INPUT_STYLES;
var init_styles = __esm({
  "src/styles.ts"() {
    MODAL_STYLES = {
      zIndex: "10000",
      display: "flex",
      header: {
        marginBottom: "15px",
        color: "var(--text-accent)";
      },
      message: {
        marginBottom: "20px",
        lineHeight: "1.5";
      },
      buttonContainer: {
        marginTop: "20px",
        display: "flex",
        gap: "10px",
        justifyContent: "flex-end";
      },
      button: {
        padding: "8px 16px",
        minWidth: "100px";
      }
    };
    INPUT_STYLES = {
      width: "100%",
      marginTop: "8px",
      padding: "8px",
      border: "1px solid var(--background-modifier-border)",
      borderRadius: "4px";
    };
  }
});

// src/dom.ts
var DOMUtils;
var init_dom = __esm({
  "src/dom.ts"() {
    init_styles();
    DOMUtils = class {
      /**
       * Apply styles to an HTML element
       */
      static applyStyles(element, styles) {
        Object.assign(element.style, styles);
      }
      /**
       * Create a standardized button container
       */
      static createButtonContainer(parent) {
        const container = parent.createDiv();
        this.applyStyles(container, MODAL_STYLES.buttonContainer);
        return container;
      }
      /**
       * Create a styled button with consistent appearance
       */
      static createStyledButton(container, text, isPrimary = false, onClick) {
        const button = container.createEl("button", { text });
        if (isPrimary) {
          button.classList.add("mod-cta");
        }
        this.applyStyles(button, MODAL_STYLES.button);
        if (onClick) {
          button.addEventListener("click", onClick);
        }
        return button;
      }
      /**
       * Create a styled input field
       */
      static createStyledInput(container, type, placeholder, value = "") {
        const input = container.createEl("input", {
          type,
          placeholder,
          value;
        });
        this.applyStyles(input, INPUT_STYLES);
        return input;
      }
      /**
       * Set up modal base styling for consistency
       */
      static setupModalStyling(modalEl) {
        this.applyStyles(modalEl, {
          zIndex: MODAL_STYLES.zIndex,
          display: MODAL_STYLES.display;
        });
      }
      /**
       * Create a header element with consistent styling
       */
      static createModalHeader(parent, text) {
        const header = parent.createEl("h2", { text });
        this.applyStyles(header, MODAL_STYLES.header);
        return header;
      }
      /**
       * Create a message paragraph with consistent styling
       */
      static createModalMessage(parent, text) {
        const message = parent.createEl("p");
        message.setText(text);
        this.applyStyles(message, MODAL_STYLES.message);
        return message;
      }
      /**
       * Set up keyboard event handlers for modals
       */
      static setupModalKeyHandlers(element, onEnter, onEscape) {
        element.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            e.stopPropagation();
            onEnter();
          }
          if (e.key === "Escape" && onEscape) {
            e.preventDefault();
            e.stopPropagation();
            onEscape();
          }
        });
      }
      // Instance methods implementing interface
      applyStyles(element, styles) {
        DOMUtils.applyStyles(element, styles);
      }
      createButtonContainer(parent) {
        return DOMUtils.createButtonContainer(parent);
      }
      createStyledButton(container, text, isPrimary = false, onClick) {
        return DOMUtils.createStyledButton(container, text, isPrimary, onClick);
      }
    };
  }
});

// src/api.ts
var API_ENDPOINTS, AI_MODELS, PROVIDER_MODEL_OPTIONS, PROVIDER_MODEL_LIST_URLS, PROVIDER_MODEL_REGEX, API_LIMITS, TIMEOUTS;
var init_api = __esm({
  "src/api.ts"() {
    API_ENDPOINTS = {
      GEMINI: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent",
      GROQ: "https://api.groq.com/openai/v1/chat/completions",
      YOUTUBE_OEMBED: "https://www.youtube.com/oembed",
      CORS_PROXY: "https://api.allorigins.win/raw";
    };
    AI_MODELS = {
      GEMINI: "gemini-2.5-pro",
      // Set Gemini model to gemini-2.5-pro
      GROQ: "llama-3.3-70b-versatile";
    };
    PROVIDER_MODEL_OPTIONS = {
      "Google Gemini": [;
        // Gemini 2.5 series (latest, all support multimodal video analysis)
        { name: "gemini-2.5-pro", supportsAudioVideo: true },
        { name: "gemini-2.5-pro-tts", supportsAudioVideo: true },
        { name: "gemini-2.5-flash", supportsAudioVideo: true },
        { name: "gemini-2.5-flash-lite", supportsAudioVideo: true },
        // Gemini 2.0 series (video support via native API, but no explicit multimodal flag)
        { name: "gemini-2.0-pro", supportsAudioVideo: true },
        { name: "gemini-2.0-flash" },
        { name: "gemini-2.0-flash-lite" },
        // Gemini 1.5 series (available, supports video via File API)
        { name: "gemini-1.5-pro" },
        { name: "gemini-1.5-flash" }
      ],
      "Groq": [;
        // Latest models (Nov 2024 - Nov 2025)
        // Note: Groq models prioritize speed/text; for multimodal video, Gemini is recommended
        { name: "llama-4-maverick-17b-128e-instruct" },
        { name: "llama-4-scout-17b-16e-instruct" },
        // Llama 3.x series
        { name: "llama-3.3-70b-versatile" },
        { name: "llama-3.1-8b-instant" }
      ];
    };
    PROVIDER_MODEL_LIST_URLS = {
      "Google Gemini": "https://developers.generativeai.google/models",
      "Groq": "https://groq.com";
    };
    PROVIDER_MODEL_REGEX = {
      "Google Gemini": /gemini[-_\.]?\d+(?:\.\d+)?(?:-[a-z0-9\-]+)?/gi,
      "Groq": /llama[-_\.]?\d+(?:\.\d+)?(?:-[a-z0-9\-]+)?/gi;
    };
    API_LIMITS = {
      MAX_TOKENS: 2e3,
      TEMPERATURE: 0.7,
      DESCRIPTION_MAX_LENGTH: 1e3,
      TITLE_MAX_LENGTH: 100;
    };
    TIMEOUTS = {
      FILE_CREATION_WAIT: 300,
      MODAL_DELAY: 100,
      FALLBACK_MODAL_CHECK: 500,
      FOCUS_DELAY: 150,
      REPAINT_DELAY: 50;
    };
  }
});

// src/confirmation-modal.ts
var confirmation_modal_exports = {};
__export(confirmation_modal_exports, {
  ConfirmationModal: () => ConfirmationModal;
});
var ConfirmationModal;
var init_confirmation_modal = __esm({
  "src/confirmation-modal.ts"() {
    init_base_modal();
    ConfirmationModal = class extends BaseModal {
      constructor(app, options) {
        super(app);
        this.options = options;
        this.result = false;
      }
      onOpen() {
        this.createModalContent();
        this.setupEventHandlers();
        this.focusConfirmButton();
      }
      /**
       * Create modal content with accessible structure
       */
      createModalContent() {
        const header = this.createHeader(this.options.title);
        header.setAttribute("id", "confirmation-modal-title");
        const messageContainer = this.contentEl.createDiv("confirmation-message");
        messageContainer.setAttribute("id", "confirmation-modal-description");
        messageContainer.textContent = this.options.message;
        const buttonContainer = this.createButtonContainer();
        buttonContainer.style.marginTop = "20px";
        const confirmText = this.options.confirmText || "Confirm";
        const cancelText = this.options.cancelText || "Cancel";
        const isDangerous = this.options.isDangerous || false;
        if (isDangerous) {
          this.cancelButton = this.createButton(;
            buttonContainer,
            cancelText,
            false,
            () => this.handleCancel();
          );
          this.cancelButton.setAttribute("aria-label", `Cancel: ${cancelText}`);
          this.confirmButton = this.createButton(;
            buttonContainer,
            confirmText,
            true,
            () => this.handleConfirm();
          );
          this.confirmButton.setAttribute("aria-label", `Confirm: ${confirmText}`);
        } else {
          this.confirmButton = this.createButton(;
            buttonContainer,
            confirmText,
            true,
            () => this.handleConfirm();
          );
          this.confirmButton.setAttribute("aria-label", `Confirm: ${confirmText}`);
          this.cancelButton = this.createButton(;
            buttonContainer,
            cancelText,
            false,
            () => this.handleCancel();
          );
          this.cancelButton.setAttribute("aria-label", `Cancel: ${cancelText}`);
        }
        this.contentEl.setAttribute("aria-labelledby", "confirmation-modal-title");
        this.contentEl.setAttribute("aria-describedby", "confirmation-modal-description");
        this.contentEl.setAttribute("role", "alertdialog");
      }
      /**
       * Set up keyboard event handlers (Enter to confirm, Escape to cancel)
       */
      setupEventHandlers() {
        this.scope.register([], "Enter", () => {
          this.handleConfirm();
          return false;
        });
        this.scope.register([], "Escape", () => {
          this.handleCancel();
          return false;
        });
      }
      /**
       * Focus the confirm button by default
       */
      focusConfirmButton() {
        if (this.confirmButton) {
          setTimeout(() => {
            this.confirmButton.focus();
          }, 50);
        }
      }
      /**
       * Handle confirmation (Confirm button or Enter key)
       */
      handleConfirm() {
        this.result = true;
        if (this.resolver) {
          this.resolver(true);
        }
        this.close();
      }
      /**
       * Handle cancellation (Cancel button or Escape key)
       */
      handleCancel() {
        this.result = false;
        if (this.resolver) {
          this.resolver(false);
        }
        this.close();
      }
      /**
       * Open modal and wait for user response
       * Returns promise that resolves to true if confirmed, false if cancelled
       */
      openAndWait() {
        return new Promise((resolve) => {
          this.resolver = resolve;
          this.open();
        });
      }
      /**
       * Get the result (synchronous if already closed)
       */
      getResult() {
        return this.result;
      }
    };
  }
});

// src/base-modal.ts
var import_obsidian3, MODAL_CSS_CLASSES, BaseModal;
var init_base_modal = __esm({
  "src/base-modal.ts"() {
    import_obsidian3 = require("obsidian");
    init_dom();
    init_styles();
    init_api();
    MODAL_CSS_CLASSES = {
      modal: "ytc-modal",
      header: "ytc-modal-header",
      content: "ytc-modal-content",
      button: "ytc-modal-button",
      input: "ytc-modal-input";
    };
    BaseModal = class extends import_obsidian3.Modal {
      constructor(app) {
        super(app);
        this.events = {};
        this.isDisposed = false;
        this.setupModalStyling();
        this.setupConflictPrevention();
      }
      /**
       * Set up base modal styling for consistency
       */
      setupModalStyling() {
        DOMUtils.setupModalStyling(this.modalEl);
        this.modalEl.addClass(MODAL_CSS_CLASSES.modal);
        this.contentEl.addClass(MODAL_CSS_CLASSES.content);
      }
      /**
       * Set up conflict prevention measures
       */
      setupConflictPrevention() {
        this.modalEl.setAttribute("data-plugin", "youtube-clipper");
        this.modalEl.style.zIndex = "9999";
      }
      /**
       * Create standardized modal header with conflict prevention
       */
      createHeader(text) {
        const header = DOMUtils.createModalHeader(this.contentEl, text);
        header.addClass(MODAL_CSS_CLASSES.header);
        return header;
      }
      /**
       * Create standardized modal message
       */
      createMessage(text) {
        return DOMUtils.createModalMessage(this.contentEl, text);
      }
      /**
       * Create standardized button container
       */
      createButtonContainer() {
        return DOMUtils.createButtonContainer(this.contentEl);
      }
      /**
      * Create standardized button with conflict prevention and accessibility
      */
      createButton(container, text, isPrimary = false, onClick) {
        const button = DOMUtils.createStyledButton(container, text, isPrimary, onClick);
        button.addClass(MODAL_CSS_CLASSES.button);
        button.setAttribute("data-plugin", "youtube-clipper");
        button.setAttribute("role", "button");
        if (!button.getAttribute("aria-label")) {
          button.setAttribute("aria-label", text);
        }
        return button;
      }
      /**
       * Create standardized input with conflict prevention and accessibility
       */
      createInput(container, type, placeholder) {
        const input = container.createEl("input", {
          type,
          placeholder;
        });
        DOMUtils.applyStyles(input, INPUT_STYLES);
        input.addClass(MODAL_CSS_CLASSES.input);
        input.setAttribute("data-plugin", "youtube-clipper");
        if (placeholder) {
          input.setAttribute("aria-label", placeholder);
        }
        return input;
      }
      /**
       * Set up keyboard event handlers
       */
      setupKeyHandlers(onEnter, onEscape) {
        const wrappedOnEnter = async () => {
          try {
            await onEnter();
          } catch (error) {
            console.error("Enter key handler error:", error);
          }
        };
        const wrappedOnEscape = onEscape ? async () => {
          try {
            await onEscape();
          } catch (error) {
            console.error("Escape key handler error:", error);
          }
        } : void 0;
        DOMUtils.setupModalKeyHandlers(this.contentEl, wrappedOnEnter, wrappedOnEscape);
      }
      /**
       * Focus element with delay for better UX
       */
      focusElement(element, delay = TIMEOUTS.FOCUS_DELAY) {
        setTimeout(() => {
          element.focus();
        }, delay);
      }
      /**
       * Set up event handlers
       */
      setEvents(events) {
        this.events = events;
      }
      /**
       * Show custom styled confirmation dialog before closing
       * This uses our custom ConfirmationModal instead of the native browser confirm()
       * for better accessibility and UX.
       *
       * Note: This is now synchronous for backwards compatibility with existing callers,
       * but returns a boolean immediately. For async confirmation with proper modal,
       * use showConfirmationModal() instead.
       */
      confirmClose(message) {
        return confirm(message);
      }
      /**
       * Show a custom accessible confirmation modal and wait for user response.
       * Preferred method for confirmation dialogs (async, fully accessible).
       */
      async showConfirmationModal(title, message, confirmText = "Confirm", cancelText = "Cancel", isDangerous = false) {
        const { ConfirmationModal: ConfirmationModal2 } = await Promise.resolve().then(() => (init_confirmation_modal(), confirmation_modal_exports));
        const modal = new ConfirmationModal2(this.app, {
          title,
          message,
          confirmText,
          cancelText,
          isDangerous;
        });
        return modal.openAndWait();
      }
      /**
       * Force modal visibility (for stubborn modals)
       */
      forceVisible() {
        setTimeout(() => {
          DOMUtils.setupModalStyling(this.modalEl);
        }, TIMEOUTS.REPAINT_DELAY);
      }
      /**
       * Clean up on close with proper disposal
       */
      onClose() {
        if (this.isDisposed) {
          return;
        }
        console.log("[youtube-clipper] Cleaning up modal");
        this.isDisposed = true;
        const { contentEl } = this;
        contentEl.empty();
        this.modalEl.removeClass(MODAL_CSS_CLASSES.modal);
        this.modalEl.removeAttribute("data-plugin");
        console.log("[youtube-clipper] Modal cleanup complete");
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => YoutubeClipperPlugin;
});
module.exports = __toCommonJS(main_exports);

// src/main.ts
var import_obsidian7 = require("obsidian");

// src/conflict-prevention.ts
var ConflictPrevention = class {
  /**
   * Check if another plugin might be conflicting
   */
  static checkForPotentialConflicts() {
    const warnings = [];
    const suspiciousElements = [;
      'div[data-plugin="web-clipper"]',
      ".web-clipper-modal",
      ".clipper-button",
      '[id*="clipper"]',
      '[class*="clip"]';
    ];
    suspiciousElements.forEach((selector) => {
      const elements = document.querySelectorAll(selector);
      if (elements.length > 0) {
        warnings.push(`Detected potential plugin conflict: ${selector}`);
      }
    });
    return warnings;
  }
  /**
   * Add conflict prevention attributes to an element
   */
  static markElement(element, type) {
    element.setAttribute("data-plugin", this.PLUGIN_ID);
    element.setAttribute("data-ytc-type", type);
    element.addClass(`${this.CSS_PREFIX}-${type}`);
  }
  /**
   * Remove conflict prevention attributes
   */
  static unmarkElement(element) {
    element.removeAttribute("data-plugin");
    element.removeAttribute("data-ytc-type");
    const classes = Array.from(element.classList);
    classes.forEach((className) => {
      if (className.startsWith(this.CSS_PREFIX)) {
        element.removeClass(className);
      }
    });
  }
  /**
   * Create a namespaced ID to prevent conflicts
   */
  static createUniqueId(base) {
    return `${this.CSS_PREFIX}-${base}-${Date.now()}`;
  }
  /**
   * Clean up all plugin elements from DOM
   */
  static cleanupAllElements() {
    const elements = document.querySelectorAll(`[data-plugin="${this.PLUGIN_ID}"]`);
    elements.forEach((element) => {
      if (element instanceof HTMLElement) {
        this.unmarkElement(element);
      }
    });
  }
  /**
   * Get safe storage key with namespace
   */
  static getStorageKey(key) {
    return `${this.PLUGIN_ID}-${key}`;
  }
  /**
   * Log plugin activity with namespace
   */
  static log(message, level = "info") {
    const timestamp = new Date().toISOString();
    const logMessage = `[${this.PLUGIN_ID}] ${timestamp} - ${message}`;
    switch (level) {
      case "warn":;
        console.warn(logMessage);
        break;
      case "error":;
        console.error(logMessage);
        break;
      default:;
        console.log(logMessage);
    }
  }
  /**
   * Check if plugin is safe to operate
   */
  static isSafeToOperate() {
    const conflicts = this.checkForPotentialConflicts();
    if (conflicts.length > 0) {
      this.log(`Potential conflicts detected: ${conflicts.join(", ")}`, "warn");
      return false;
    }
    return true;
  }
  /**
   * Wrap async operations with conflict checking
   */
  static async safeOperation(operation, operationName) {
    if (!this.isSafeToOperate()) {
      this.log(`Skipping ${operationName} due to potential conflicts`, "warn");
      return null;
    }
    try {
      this.log(`Starting ${operationName}`);
      const result = await operation();
      this.log(`Completed ${operationName}`);
      return result;
    } catch (error) {
      this.log(`Error in ${operationName}: ${error}`, "error");
      throw error;
    }
  }
};
ConflictPrevention.PLUGIN_ID = "youtube-clipper";
ConflictPrevention.CSS_PREFIX = "ytc";

// src/messages.ts
var MESSAGES = {
  PROCESSING: "Processing YouTube video...",
  SUCCESS: (title) => `Successfully processed: ${title}`,
  OPENED_FILE: (filename) => `Opened: ${filename}`,
  ERRORS: {
    INVALID_URL: "Invalid YouTube URL. Please provide a valid YouTube video URL (e.g., https://www.youtube.com/watch?v=VIDEO_ID)",
    MISSING_API_KEYS: "No valid Gemini or Groq API key configured. Please set one in plugin settings.",
    GEMINI_INVALID_KEY: "Gemini API key is invalid or missing. Please check your key.",
    GROQ_MODEL_NOT_FOUND: "Groq API error: Model not found or you do not have access. Please check your API key and model name.",
    FETCH_VIDEO_DATA: (status) => `Failed to fetch video metadata: ${status}`,
    SAVE_FILE: (message) => `Failed to save file: ${message}`,
    AI_PROCESSING: (message) => `AI processing failed: ${message}`,
    FILE_NOT_EXISTS: "File no longer exists",
    COULD_NOT_OPEN: (message) => `Could not open file: ${message}`,
    ENTER_URL: "Please enter a YouTube URL",
    VIDEO_ID_EXTRACTION: "Could not extract video ID from URL. Please check the URL format.",
    NETWORK_ERROR: "Network error occurred. Please check your internet connection and try again.";
  },
  WARNINGS: {
    CORS_RESTRICTIONS: "Description not available due to CORS restrictions",
    EXTRACTION_FAILED: "Description extraction failed",
    AUTO_EXTRACTION: "Video description could not be extracted automatically.";
  },
  MODALS: {
    YOUTUBE_PROCESSED: "YouTube Video Processed",
    CONFIRM_OPEN: (filename) => `Successfully processed YouTube video and saved as "${filename}". Would you like to open the note now?`,
    CLOSE_CONFIRMATION: "Close without opening the note?",
    PROCESS_VIDEO: "Process YouTube Video",
    YES_OPEN: "Yes, open note",
    NO_THANKS: "No, thanks",
    CANCEL: "Cancel",
    PROCESS: "Process";
  },
  PLACEHOLDERS: {
    YOUTUBE_URL: "https://www.youtube.com/watch?v=...",
    GEMINI_KEY: "AIza...",
    GROQ_KEY: "gsk_...",
    OUTPUT_PATH: "YouTube/Processed Videos";
  }
};

// src/validation.ts
var ValidationUtils = class {
  /**
   * Clean and normalize YouTube URL
   */
  static cleanYouTubeUrl(url) {
    if (!url || typeof url !== "string") {
      return "";
    }
    let cleanUrl = url.trim();
    cleanUrl = cleanUrl.replace(/[\u200B-\u200D\uFEFF]/g, "");
    if (!cleanUrl.startsWith("http://") && !cleanUrl.startsWith("https://")) {
      cleanUrl = "https://" + cleanUrl;
    }
    if (cleanUrl.startsWith("http://youtube.com") || cleanUrl.startsWith("http://www.youtube.com")) {
      cleanUrl = cleanUrl.replace("http://", "https://");
    }
    return cleanUrl;
  }
  /**
   * Extract YouTube video ID from URL (memoized for performance)
   * Enhanced extraction with better error handling
   */
  static extractVideoId(url) {
    if (!url || typeof url !== "string")
      return null;
    if (this.URL_CACHE.has(url)) {
      return this.URL_CACHE.get(url);
    }
    const cleanUrl = this.cleanYouTubeUrl(url);
    let result = null;
    let match = cleanUrl.match(this.URL_PATTERNS[0]);
    if ((match == null ? void 0 : match[1]) && this.VIDEO_ID_REGEX.test(match[1])) {
      result = match[1];
    } else {
      for (let i = 1; i < this.URL_PATTERNS.length && !result; i++) {
        match = cleanUrl.match(this.URL_PATTERNS[i]);
        if ((match == null ? void 0 : match[1]) && this.VIDEO_ID_REGEX.test(match[1])) {
          result = match[1];
        }
      }
    }
    if (this.URL_CACHE.size > 100) {
      this.URL_CACHE.clear();
    }
    this.URL_CACHE.set(url, result);
    if (!result) {
      console.warn("Failed to extract video ID from URL:", url);
    }
    return result;
  }
  /**
   * Validate YouTube URL format
   */
  static isValidYouTubeUrl(url) {
    return this.extractVideoId(url) !== null;
  }
  /**
   * Sanitize filename for file system compatibility
   */
  static sanitizeFilename(filename, maxLength = 100) {
    return filename.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim().substring(0, maxLength);
  }
  /**
   * Validate API key format
   */
  static isValidAPIKey(key, provider) {
    if (!key || typeof key !== "string") {
      return false;
    }
    switch (provider) {
      case "gemini":;
        return key.startsWith("AIza") && key.length > 10;
      case "groq":;
        return key.startsWith("gsk_") && key.length > 10;
      default:;
        return false;
    }
  }
  /**
   * Validate settings configuration
   */
  static validateSettings(settings) {
    const errors = [];
    const usingEnv = Boolean(settings.useEnvironmentVariables);
    const hasDirectKey = this.isNonEmptyString(settings.geminiApiKey) || this.isNonEmptyString(settings.groqApiKey);
    if (!hasDirectKey && !usingEnv) {
      errors.push(MESSAGES.ERRORS.MISSING_API_KEYS);
    }
    if (this.isNonEmptyString(settings.geminiApiKey) && !this.isValidAPIKey(settings.geminiApiKey, "gemini")) {
      errors.push("Invalid Gemini API key format");
    }
    if (this.isNonEmptyString(settings.groqApiKey) && !this.isValidAPIKey(settings.groqApiKey, "groq")) {
      errors.push("Invalid Groq API key format");
    }
    if (usingEnv && !this.isNonEmptyString(settings.environmentPrefix)) {
      errors.push("Environment variable prefix is required when using environment variables");
    }
    if (!settings.outputPath || typeof settings.outputPath !== "string") {
      errors.push("Output path is required");
    }
    return {
      isValid: errors.length === 0,
      errors;
    };
  }
  /**
   * Validate file path
   */
  static isValidPath(path) {
    return typeof path === "string" && path.trim().length > 0;
  }
  /**
   * Validate that a string is not empty
   */
  static isNonEmptyString(value) {
    return typeof value === "string" && value.trim().length > 0;
  }
  /**
   * Truncate text to specified length with ellipsis
   */
  static truncateText(text, maxLength) {
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength - 3) + "...";
  }
  /**
   * Clean HTML entities and escape sequences from text
   */
  static cleanText(text) {
    return text.replace(/\\n/g, "\n").replace(/\\"/g, '"').replace(/\\'/g, "'").replace(;
      /\\u([0-9a-fA-F]{4})/g,
      (match, code) => String.fromCharCode(parseInt(code, 16));
    );
  }
};
/**
 * YouTube URL patterns for validation (ordered by frequency for performance)
 * Enhanced patterns to handle various YouTube URL formats
 */
ValidationUtils.URL_PATTERNS = [;
  // Standard youtube.com/watch?v= format (most common)
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})(?:&.*)?$/,
  // youtu.be short format (second most common)
  /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // youtube.com/embed format
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // youtube.com/v format
  /(?:https?:\/\/)?(?:www\.)?youtube\.com\/v\/([a-zA-Z0-9_-]{11})(?:\?.*)?$/,
  // Mobile youtube.com format
  /(?:https?:\/\/)?(?:m\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})(?:&.*)?$/;
];
// Memoized regex for video ID validation (hot path optimization)
ValidationUtils.VIDEO_ID_REGEX = /^[a-zA-Z0-9_-]{11}$/;
ValidationUtils.URL_CACHE = /* @__PURE__ */ new Map();

// src/services/error-handler.ts
var import_obsidian = require("obsidian");
var ErrorHandler = class {
  /**
   * Handle errors with consistent logging and user feedback
   */
  static handle(error, context, showNotice = true) {
    const errorMessage = `${context}: ${error.message}`;
    console.error(errorMessage, error);
    if (showNotice) {
      new import_obsidian.Notice(`Error: ${error.message}`);
    }
  }
  /**
   * Execute an operation with automatic error handling
   */
  static async withErrorHandling(operation, context, showNotice = true) {
    try {
      return await operation();
    } catch (error) {
      this.handle(error, context, showNotice);
      return null;
    }
  }
  /**
   * Execute a synchronous operation with error handling
   */
  static withSyncErrorHandling(operation, context, showNotice = true) {
    try {
      return operation();
    } catch (error) {
      this.handle(error, context, showNotice);
      return null;
    }
  }
  /**
   * Create a standardized error for API responses
   */
  static createAPIError(provider, status, statusText, details) {
    const message = `${provider} API error: ${status} ${statusText}${details ? `. ${details}` : ""}`;
    return new Error(message);
  }
  /**
   * Handle API response errors with consistent format
   */
  static async handleAPIError(response, provider, fallbackMessage) {
    var _a;
    let errorDetails = fallbackMessage || "";
    try {
      const errorData = await response.json();
      errorDetails = ((_a = errorData.error) == null ? void 0 : _a.message) || errorData.message || fallbackMessage || "";
    } catch (e) {
    }
    throw this.createAPIError(provider, response.status, response.statusText, errorDetails);
  }
  /**
   * Validate required configuration and throw descriptive errors
   */
  static validateConfiguration(config, requiredFields) {
    const missing = requiredFields.filter((field) => !config[field]);
    if (missing.length > 0) {
      throw new Error(`Missing required configuration: ${missing.join(", ")}`);
    }
  }
  /**
   * Create a user-friendly error message for common scenarios
   */
  static createUserFriendlyError(error, operation) {
    const message = `Failed to ${operation}: ${error.message}`;
    return new Error(message);
  }
  // Instance methods implementing interface
  handle(error, context, showNotice = true) {
    ErrorHandler.handle(error, context, showNotice);
  }
  async withErrorHandling(operation, context) {
    return ErrorHandler.withErrorHandling(operation, context);
  }
};

// src/save-confirmation-modal.ts
var import_obsidian2 = require("obsidian");
var SaveConfirmationModal = class extends import_obsidian2.Modal {
  constructor(app, file, onConfirm) {
    super(app);
    this.file = file;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    try {
      contentEl.createEl("h2", { text: "Note created successfully. Open now?" });
      const buttonContainer = contentEl.createDiv("save-confirmation-buttons");
      new import_obsidian2.Setting(buttonContainer).addButton((btn) => btn.setButtonText("Open Note").setCta().onClick(() => {
        this.close();
        this.onConfirm(true);
      })).addButton((btn) => btn.setButtonText("Dismiss").onClick(() => {
        this.close();
        this.onConfirm(false);
      }));
      setTimeout(() => {
        const openButton = buttonContainer.querySelector("button");
        if (openButton) {
          openButton.focus();
        }
      }, 100);
    } catch (error) {
      console.error("[SaveConfirmationModal] Error in onOpen:", error);
      contentEl.createEl("h2", { text: "File Saved" });
      contentEl.createEl("p", { text: `File "${this.file.name}" has been saved successfully.` });
      contentEl.createEl("button", { text: "OK" }).onclick = () => this.close();
    }
  }
  /**
   * Get human-readable file size
   */
  getFileSize() {
    try {
      const stat = this.app.vault.adapter.stat(this.file.path);
      if (stat && typeof stat === "object" && "size" in stat) {
        const bytes = stat.size;
        if (bytes < 1024)
          return `${bytes} bytes`;
        if (bytes < 1024 * 1024)
          return `${(bytes / 1024).toFixed(1)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
      }
    } catch (error) {
    }
    return "";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Add custom styles for the modal
   */
  addStyles() {
    var _a;
    const { contentEl } = this;
    contentEl.addClass("ytp-save-confirmation-modal");
    const style = document.createElement("style");
    style.textContent = `;
            .ytp-save-confirmation-modal {
                min-width: 450px;
                max-width: 650px;
            }

            .save-confirmation-message {
                margin: 20px 0 30px 0;
                text-align: left;
                line-height: 1.6;
            }

            .save-confirmation-filename {
                font-weight: bold;
                font-size: 1.1em;
                margin-bottom: 15px;
                color: var(--text-accent);
                text-align: center;
            }

            .save-confirmation-location-container,
            .save-confirmation-size-container {
                margin-bottom: 10px;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .save-confirmation-location {
                font-family: var(--font-monospace);
                background: var(--background-secondary);
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.9em;
                word-break: break-all;
                color: var(--text-muted);
                flex: 1;
            }

            .save-confirmation-size {
                font-family: var(--font-monospace);
                background: var(--background-modifier-success);
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.9em;
                color: var(--text-on-accent);
            }

            .save-confirmation-buttons {
                text-align: center;
                margin-top: 20px;
                display: flex;
                justify-content: center;
                gap: 15px;
            }

            .save-confirmation-buttons .setting-item {
                border: none;
                padding: 0;
                margin: 0;
                display: flex;
                gap: 10px;
            }

            .save-confirmation-buttons button {
                min-width: 100px;
                padding: 8px 20px;
                font-size: 1em;
            }

            .save-confirmation-buttons button:first-child {
                /* Open File button - primary action */
                background-color: var(--interactive-accent);
                color: var(--text-on-accent);
            }

            .save-confirmation-buttons button:last-child {
                /* OK button - secondary action */
                background-color: var(--background-modifier-border);
                color: var(--text-normal);
            }
        `;
    document.head.appendChild(style);
    (_a = this.modalEl) == null ? void 0 : _a.setAttribute("data-style-id", "ytp-save-confirmation-style");
  }
};

// src/youtube-url-modal.ts
var import_obsidian4 = require("obsidian");
init_base_modal();
init_api();
var YouTubeUrlModal = class extends BaseModal {
  constructor(app, options) {
    super(app);
    this.options = options;
    this.url = "";
    this.format = "executive-summary";
    this.fetchInProgress = false;
    this.progressSteps = [];
    this.currentStepIndex = 0;
    this.isProcessing = false;
    this.url = options.initialUrl || "";
  }
  onOpen() {
    this.createModalContent();
    this.setupEventHandlers();
    if (this.options.initialUrl) {
      if (this.url.trim() === this.options.initialUrl.trim()) {
        console.debug("YouTubeUrlModal: Same URL already set, preventing cycle");
      } else {
        this.setUrl(this.options.initialUrl);
      }
      this.updateProcessButtonState();
      const isValid = ValidationUtils.isValidYouTubeUrl((this.options.initialUrl || "").trim());
      if (isValid && this.processButton) {
        this.processButton.focus();
        return;
      }
    }
    this.focusUrlInput();
  }
  /**
   * Create modal content
   */
  createModalContent() {
    this.headerEl = this.createHeader(MESSAGES.MODALS.PROCESS_VIDEO);
    this.createUrlInputSection();
    this.createFormatSelectionSection();
    this.createProviderSelectionSection();
    this.createProgressSection();
    this.createActionButtons();
  }
  createProviderSelectionSection() {
    const container = this.contentEl.createDiv();
    container.style.marginTop = "10px";
    const label = container.createEl("label", { text: "AI Provider & Model:" });
    label.setAttribute("for", "ytc-provider-select");
    const row = container.createDiv();
    row.style.display = "flex";
    row.style.gap = "8px";
    row.style.alignItems = "center";
    this.providerSelect = document.createElement("select");
    this.providerSelect.id = "ytc-provider-select";
    this.providerSelect.setAttribute("aria-label", "AI Provider");
    this.providerSelect.style.flex = "1";
    this.providerSelect.style.padding = "6px";
    this.providerSelect.style.borderRadius = "6px";
    this.providerSelect.style.border = "1px solid var(--background-modifier-border)";
    row.appendChild(this.providerSelect);
    this.modelSelect = document.createElement("select");
    this.modelSelect.id = "ytc-model-select";
    this.modelSelect.setAttribute("aria-label", "AI Model");
    this.modelSelect.style.width = "220px";
    this.modelSelect.style.padding = "6px";
    this.modelSelect.style.borderRadius = "6px";
    this.modelSelect.style.border = "1px solid var(--background-modifier-border)";
    row.appendChild(this.modelSelect);
    const providers = this.options.providers || [];
    const modelOptions = this.options.modelOptions || {};
    const autoOpt = document.createElement("option");
    autoOpt.value = "";
    autoOpt.text = "Auto (fallback)";
    this.providerSelect.appendChild(autoOpt);
    providers.forEach((p) => {
      const opt = document.createElement("option");
      opt.value = p;
      opt.text = p;
      this.providerSelect.appendChild(opt);
    });
    const refreshBtn = this.createInlineButton(row, "Refresh models", () => {
      void this.handleRefreshModels();
    });
    this.refreshSpinner = document.createElement("span");
    this.refreshSpinner.style.display = "none";
    this.refreshSpinner.style.marginLeft = "8px";
    this.refreshSpinner.style.width = "16px";
    this.refreshSpinner.style.height = "16px";
    this.refreshSpinner.style.border = "2px solid var(--background-modifier-border)";
    this.refreshSpinner.style.borderTop = "2px solid var(--interactive-accent)";
    this.refreshSpinner.style.borderRadius = "50%";
    this.refreshSpinner.style.animation = "ytp-spin 1s linear infinite";
    row.appendChild(this.refreshSpinner);
    this.providerSelect.addEventListener("change", () => {
      this.selectedProvider = this.providerSelect.value || void 0;
      this.populateModelsForProvider(this.selectedProvider || "", modelOptions, this.options.defaultModel);
    });
    if (this.options.defaultProvider) {
      this.providerSelect.value = this.options.defaultProvider;
      this.selectedProvider = this.options.defaultProvider;
    }
    this.populateModelsForProvider(this.selectedProvider || "", modelOptions, this.options.defaultModel);
  }
  async handleRefreshModels() {
    if (!this.options.fetchModels) {
      this.setValidationMessage("Model refresh not available.", "error");
      return;
    }
    this.setValidationMessage("Refreshing model lists\u2026", "info");
    if (this.refreshSpinner)
      this.refreshSpinner.style.display = "inline-block";
    try {
      const map = await this.options.fetchModels();
      const providers = Object.keys(map);
      if (this.providerSelect) {
        const current = this.providerSelect.value;
        this.providerSelect.innerHTML = "";
        const autoOpt = document.createElement("option");
        autoOpt.value = "";
        autoOpt.text = "Auto (fallback)";
        this.providerSelect.appendChild(autoOpt);
        providers.forEach((p) => {
          const opt = document.createElement("option");
          opt.value = p;
          opt.text = p;
          this.providerSelect.appendChild(opt);
        });
        if (current && Array.from(this.providerSelect.options).some((o) => o.value === current)) {
          this.providerSelect.value = current;
          this.selectedProvider = current;
        }
      }
      const modelOptions = map;
      this.populateModelsForProvider(this.selectedProvider || "", modelOptions, this.options.defaultModel);
      this.setValidationMessage("Model lists refreshed.", "success");
    } catch (error) {
      this.setValidationMessage("Failed to refresh models. Using cached options.", "error");
    } finally {
      if (this.refreshSpinner)
        this.refreshSpinner.style.display = "none";
    }
  }
  populateModelsForProvider(providerName, modelOptions, defaultModel) {
    if (!this.modelSelect)
      return;
    this.modelSelect.innerHTML = "";
    const models = modelOptions[providerName] || [];
    if (models.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.text = "Default model";
      this.modelSelect.appendChild(opt);
      this.selectedModel = "";
      return;
    }
    models.forEach((m) => {
      const opt = document.createElement("option");
      opt.value = m;
      let label = m;
      try {
        const providerModels = PROVIDER_MODEL_OPTIONS[providerName] || [];
        const match = providerModels.find((pm) => {
          const name = typeof pm === "string" ? pm : pm && pm.name ? pm.name : "";
          return String(name).toLowerCase() === String(m).toLowerCase();
        });
        if (match && match.supportsAudioVideo) {
          label = `${m}  \u{1F3A5}`;
          opt.title = "Supports multimodal audio/video tokens";
        }
      } catch (err) {
      }
      opt.text = label;
      this.modelSelect.appendChild(opt);
    });
    if (defaultModel && models.includes(defaultModel)) {
      this.modelSelect.value = defaultModel;
      this.selectedModel = defaultModel;
    } else {
      this.modelSelect.selectedIndex = 0;
      this.selectedModel = this.modelSelect.value;
    }
    this.modelSelect.addEventListener("change", () => {
      this.selectedModel = this.modelSelect.value;
    });
  }
  /**
   * Create URL input section
   */
  createUrlInputSection() {
    const container = this.contentEl.createDiv();
    const label = container.createEl("label", { text: "YouTube URL:" });
    label.setAttribute("for", "ytc-url-input");
    const inputRow = container.createDiv();
    inputRow.style.display = "flex";
    inputRow.style.gap = "8px";
    inputRow.style.alignItems = "center";
    this.urlInput = this.createInput(;
      inputRow,
      "url",
      MESSAGES.PLACEHOLDERS.YOUTUBE_URL + " (Press Enter to process)";
    );
    this.urlInput.id = "ytc-url-input";
    this.urlInput.setAttribute("aria-label", "YouTube URL");
    this.urlInput.setAttribute("aria-describedby", "ytc-url-hint");
    this.urlInput.style.flex = "1";
    this.urlInput.style.transition = "border-color 0.2s ease, box-shadow 0.2s ease";
    this.pasteButton = this.createInlineButton(inputRow, "Paste", () => {
      void this.handlePasteFromClipboard();
    });
    this.pasteButton.setAttribute("aria-label", "Paste YouTube URL from clipboard");
    this.clearButton = this.createInlineButton(inputRow, "Clear", () => {
      this.handleClearUrl();
    });
    this.clearButton.setAttribute("aria-label", "Clear YouTube URL input");
    if (this.options.initialUrl) {
      this.urlInput.value = this.options.initialUrl;
      this.url = this.options.initialUrl;
    }
    this.urlInput.addEventListener("input", (e) => {
      this.url = e.target.value;
      this.updateProcessButtonState();
      this.updateQuickActionsState();
    });
    this.validationMessage = container.createDiv();
    this.validationMessage.id = "ytc-url-hint";
    this.validationMessage.style.marginTop = "6px";
    this.validationMessage.style.fontSize = "0.85rem";
    this.validationMessage.style.color = "var(--text-muted)";
    this.validationMessage.setAttribute("role", "status");
    this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
    const preview = container.createDiv();
    preview.style.display = "flex";
    preview.style.gap = "10px";
    preview.style.alignItems = "center";
    preview.style.marginTop = "8px";
    this.thumbnailEl = preview.createEl("img");
    this.thumbnailEl.setAttribute("aria-label", "Video thumbnail");
    this.thumbnailEl.style.width = "120px";
    this.thumbnailEl.style.height = "68px";
    this.thumbnailEl.style.objectFit = "cover";
    this.thumbnailEl.style.borderRadius = "4px";
    this.thumbnailEl.style.display = "none";
    this.metadataContainer = preview.createDiv();
    this.metadataContainer.setAttribute("aria-label", "Video metadata");
    this.metadataContainer.style.display = "none";
    this.metadataContainer.style.fontSize = "0.9rem";
    this.metadataContainer.style.color = "var(--text-normal)";
    this.metadataContainer.createDiv({ cls: "yt-preview-title" });
    this.metadataContainer.createDiv({ cls: "yt-preview-channel" });
    this.setUrlInputState("idle");
    this.updateQuickActionsState();
  }
  /**
   * Create format selection section with radio buttons
   */
  createFormatSelectionSection() {
    const container = this.contentEl.createDiv();
    const label = container.createEl("label", { text: "Output Format:" });
    label.id = "format-group-label";
    const radioContainer = container.createDiv();
    radioContainer.setAttribute("role", "group");
    radioContainer.setAttribute("aria-labelledby", "format-group-label");
    radioContainer.style.marginTop = "8px";
    radioContainer.style.display = "flex";
    radioContainer.style.gap = "20px";
    radioContainer.style.flexWrap = "wrap";
    const executiveContainer = radioContainer.createDiv();
    executiveContainer.style.display = "flex";
    executiveContainer.style.alignItems = "center";
    executiveContainer.style.gap = "8px";
    const executiveRadio = executiveContainer.createEl("input");
    executiveRadio.type = "radio";
    executiveRadio.name = "outputFormat";
    executiveRadio.value = "executive-summary";
    executiveRadio.id = "executive-radio";
    executiveRadio.checked = this.format === "executive-summary";
    executiveRadio.setAttribute("aria-label", "Executive Summary format");
    const executiveLabel = executiveContainer.createEl("label");
    executiveLabel.setAttribute("for", "executive-radio");
    executiveLabel.textContent = "Executive";
    executiveLabel.style.cursor = "pointer";
    const tutorialContainer = radioContainer.createDiv();
    tutorialContainer.style.display = "flex";
    tutorialContainer.style.alignItems = "center";
    tutorialContainer.style.gap = "8px";
    const tutorialRadio = tutorialContainer.createEl("input");
    tutorialRadio.type = "radio";
    tutorialRadio.name = "outputFormat";
    tutorialRadio.value = "detailed-guide";
    tutorialRadio.id = "tutorial-radio";
    tutorialRadio.checked = this.format === "detailed-guide";
    tutorialRadio.setAttribute("aria-label", "Detailed Guide format");
    const tutorialLabel = tutorialContainer.createEl("label");
    tutorialLabel.setAttribute("for", "tutorial-radio");
    tutorialLabel.textContent = "Tutorial";
    tutorialLabel.style.cursor = "pointer";
    executiveRadio.addEventListener("change", (e) => {
      if (e.target.checked) {
        this.format = "executive-summary";
        if (this.customPromptContainer) {
          this.customPromptContainer.style.display = "none";
        }
      }
    });
    tutorialRadio.addEventListener("change", (e) => {
      if (e.target.checked) {
        this.format = "detailed-guide";
        if (this.customPromptContainer) {
          this.customPromptContainer.style.display = "none";
        }
      }
    });
    const briefContainer = radioContainer.createDiv();
    briefContainer.style.display = "flex";
    briefContainer.style.alignItems = "center";
    briefContainer.style.gap = "8px";
    const briefRadio = briefContainer.createEl("input");
    briefRadio.type = "radio";
    briefRadio.name = "outputFormat";
    briefRadio.value = "brief";
    briefRadio.id = "brief-radio";
    briefRadio.checked = this.format === "brief";
    briefRadio.setAttribute("aria-label", "Brief format");
    const briefLabel = briefContainer.createEl("label");
    briefLabel.setAttribute("for", "brief-radio");
    briefLabel.textContent = "Brief";
    briefLabel.style.cursor = "pointer";
    briefRadio.addEventListener("change", (e) => {
      if (e.target.checked) {
        this.format = "brief";
        if (this.customPromptContainer) {
          this.customPromptContainer.style.display = "none";
        }
      }
    });
    const customContainer = radioContainer.createDiv();
    customContainer.style.display = "flex";
    customContainer.style.alignItems = "center";
    customContainer.style.gap = "8px";
    const customRadio = customContainer.createEl("input");
    customRadio.type = "radio";
    customRadio.name = "outputFormat";
    customRadio.value = "custom";
    customRadio.id = "custom-radio";
    customRadio.checked = this.format === "custom";
    customRadio.setAttribute("aria-label", "Custom prompt format");
    const customLabel = customContainer.createEl("label");
    customLabel.setAttribute("for", "custom-radio");
    customLabel.textContent = "Custom";
    customLabel.style.cursor = "pointer";
    customRadio.addEventListener("change", (e) => {
      var _a;
      if (e.target.checked) {
        this.format = "custom";
        if (this.customPromptContainer) {
          this.customPromptContainer.style.display = "block";
          (_a = this.customPromptInput) == null ? void 0 : _a.focus();
        }
      }
    });
    this.customPromptContainer = container.createDiv();
    this.customPromptContainer.style.marginTop = "12px";
    this.customPromptContainer.style.padding = "12px";
    this.customPromptContainer.style.backgroundColor = "var(--background-modifier-hover)";
    this.customPromptContainer.style.borderRadius = "4px";
    this.customPromptContainer.style.display = "none";
    const customPromptLabel = this.customPromptContainer.createEl("label", {
      text: "Custom Prompt (this session only):";
    });
    customPromptLabel.setAttribute("for", "custom-prompt-input");
    customPromptLabel.style.display = "block";
    customPromptLabel.style.marginBottom = "6px";
    customPromptLabel.style.fontWeight = "600";
    customPromptLabel.style.fontSize = "0.95rem";
    this.customPromptInput = this.customPromptContainer.createEl("textarea");
    this.customPromptInput.id = "custom-prompt-input";
    this.customPromptInput.setAttribute("aria-label", "Custom AI prompt");
    this.customPromptInput.setAttribute("placeholder", "Enter your custom prompt here. Available placeholders: __VIDEO_TITLE__, __VIDEO_DESCRIPTION__, __VIDEO_URL__");
    this.customPromptInput.style.width = "100%";
    this.customPromptInput.style.height = "100px";
    this.customPromptInput.style.padding = "8px";
    this.customPromptInput.style.fontFamily = "monospace";
    this.customPromptInput.style.fontSize = "12px";
    this.customPromptInput.style.border = "1px solid var(--background-modifier-border)";
    this.customPromptInput.style.borderRadius = "4px";
    this.customPromptInput.style.resize = "vertical";
    this.customPromptInput.style.marginBottom = "6px";
    const helpText = this.customPromptContainer.createEl("small");
    helpText.textContent = "Placeholders: __VIDEO_TITLE__, __VIDEO_DESCRIPTION__, __VIDEO_URL__, __VIDEO_ID__, __EMBED_URL__, __DATE__, __TIMESTAMP__";
    helpText.style.display = "block";
    helpText.style.marginTop = "4px";
    helpText.style.color = "var(--text-muted)";
    helpText.style.fontSize = "11px";
  }
  /**
   * Create progress section
   */
  createProgressSection() {
    this.progressContainer = this.contentEl.createDiv();
    this.progressContainer.setAttribute("role", "region");
    this.progressContainer.setAttribute("aria-label", "Processing progress");
    this.progressContainer.setAttribute("aria-live", "polite");
    this.progressContainer.style.marginTop = "16px";
    this.progressContainer.style.display = "none";
    this.progressText = this.progressContainer.createDiv();
    this.progressText.id = "progress-text";
    this.progressText.style.marginBottom = "8px";
    this.progressText.style.fontWeight = "500";
    this.progressText.style.color = "var(--text-accent)";
    this.progressText.textContent = "Processing video...";
    const progressBarContainer = this.progressContainer.createDiv();
    progressBarContainer.setAttribute("role", "progressbar");
    progressBarContainer.setAttribute("aria-valuenow", "0");
    progressBarContainer.setAttribute("aria-valuemin", "0");
    progressBarContainer.setAttribute("aria-valuemax", "100");
    progressBarContainer.setAttribute("aria-labelledby", "progress-text");
    progressBarContainer.style.width = "100%";
    progressBarContainer.style.height = "6px";
    progressBarContainer.style.backgroundColor = "var(--background-modifier-border)";
    progressBarContainer.style.borderRadius = "3px";
    progressBarContainer.style.overflow = "hidden";
    this.progressBar = progressBarContainer.createDiv();
    this.progressBar.style.height = "100%";
    this.progressBar.style.backgroundColor = "var(--text-accent)";
    this.progressBar.style.borderRadius = "3px";
    this.progressBar.style.width = "0%";
    this.progressBar.style.transition = "width 0.3s ease";
    const stepList = this.progressContainer.createEl("ol");
    stepList.setAttribute("aria-label", "Processing steps");
    stepList.style.marginTop = "12px";
    stepList.style.paddingLeft = "20px";
    stepList.style.fontSize = "0.9rem";
    stepList.style.color = "var(--text-normal)";
    const labels = [;
      "Validate URL",
      "Fetch video info",
      "Run AI analysis",
      "Save note";
    ];
    this.progressSteps = labels.map((label) => {
      const item = stepList.createEl("li");
      item.setAttribute("role", "status");
      item.style.marginBottom = "4px";
      item.textContent = `\u25CB ${label}`;
      return { label, element: item };
    });
  }
  /**
   * Create action buttons with accessibility
   */
  createActionButtons() {
    const container = this.createButtonContainer();
    const cancelBtn = this.createButton(;
      container,
      MESSAGES.MODALS.CANCEL,
      false,
      () => this.close();
    );
    cancelBtn.setAttribute("aria-label", "Cancel video processing");
    this.processButton = this.createButton(;
      container,
      MESSAGES.MODALS.PROCESS,
      true,
      () => this.handleProcess();
    );
    this.processButton.setAttribute("aria-label", "Process YouTube video");
    this.openButton = this.createButton(;
      container,
      "Open Note",
      true,
      () => this.handleOpenFile();
    );
    this.openButton.setAttribute("aria-label", "Open the processed note");
    this.openButton.style.display = "none";
    this.updateProcessButtonState();
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.setupKeyHandlers(;
      () => this.handleProcess(),
      () => this.close();
    );
  }
  /**
   * Focus on URL input
   */
  focusUrlInput() {
    if (this.urlInput) {
      this.focusElement(this.urlInput);
    }
  }
  /**
   * Update process button enabled state (optimized with debouncing and memoization)
   */
  updateProcessButtonState() {
    if (!this.processButton)
      return;
    if (this.isProcessing) {
      return;
    }
    const trimmedUrl = this.url.trim();
    if (this.processButton && this.processButton.textContent !== MESSAGES.MODALS.PROCESS && trimmedUrl.length >= 0) {
      this.processButton.textContent = MESSAGES.MODALS.PROCESS;
    }
    if (trimmedUrl === this.lastValidUrl) {
      const isValid = this.lastValidResult;
      this.processButton.disabled = !isValid;
      this.processButton.style.opacity = isValid ? "1" : "0.5";
      if (trimmedUrl.length === 0) {
        this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
        this.setUrlInputState("idle");
      } else {
        this.setValidationMessage(;
          isValid ? "Ready to process this video." : "Enter a valid YouTube video URL.",
          isValid ? "success" : "error";
        );
        this.setUrlInputState(isValid ? "valid" : "invalid");
      }
      this.updateQuickActionsState();
      return;
    }
    if (this.validationTimer) {
      clearTimeout(this.validationTimer);
    }
    this.validationTimer = window.setTimeout(() => {
      const isValid = ValidationUtils.isValidYouTubeUrl(trimmedUrl);
      this.lastValidUrl = trimmedUrl;
      this.lastValidResult = isValid;
      this.processButton.disabled = !isValid;
      this.processButton.style.opacity = isValid ? "1" : "0.5";
      if (trimmedUrl.length === 0) {
        this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
        this.setUrlInputState("idle");
      } else {
        this.setValidationMessage(;
          isValid ? "Ready to process this video." : "Enter a valid YouTube video URL.",
          isValid ? "success" : "error";
        );
        this.setUrlInputState(isValid ? "valid" : "invalid");
      }
      this.updateQuickActionsState();
      if (isValid) {
        void this.maybeFetchPreview(trimmedUrl);
      } else {
        this.clearPreview();
      }
    }, 300);
  }
  /**
   * Validate URL input (simplified - used by debounced handler)
   */
  isUrlValid() {
    return ValidationUtils.isValidYouTubeUrl(this.url.trim());
  }
  /**
   * Handle process button click
   */
  async handleProcess() {
    var _a;
    const trimmedUrl = this.url.trim();
    if (!trimmedUrl) {
      new import_obsidian4.Notice(MESSAGES.ERRORS.ENTER_URL);
      this.focusUrlInput();
      return;
    }
    if (!this.isUrlValid()) {
      new import_obsidian4.Notice(MESSAGES.ERRORS.INVALID_URL);
      this.focusUrlInput();
      return;
    }
    try {
      if (this.selectedProvider === "Google Gemini" && this.selectedModel && this.isUrlValid()) {
        try {
          const models = PROVIDER_MODEL_OPTIONS["Google Gemini"] || [];
          const match = models.find((m) => {
            const name = typeof m === "string" ? m : m && m.name ? m.name : "";
            return String(name).toLowerCase() === String(this.selectedModel || "").toLowerCase();
          });
          const supportsAudioVideo = !!(match && match.supportsAudioVideo);
          if (!supportsAudioVideo) {
            const recommended = (models.find((m) => m && m.supportsAudioVideo) || { name: AI_MODELS.GEMINI }).name;
            const shouldSwitch = await this.showConfirmationModal(;
              "Multimodal Model Recommended",
              `The selected model (${this.selectedModel}) may not support multimodal analysis.;

Would you like to switch to a multimodal-capable model (${recommended}) for better video analysis?`,
              "Switch to Multimodal",
              "Keep Current Model",
              false;
            );
            if (shouldSwitch) {
              if (this.modelSelect) {
                const exists = Array.from(this.modelSelect.options).some((o) => o.value === recommended);
                if (!exists) {
                  const opt = document.createElement("option");
                  opt.value = recommended;
                  opt.text = recommended;
                  this.modelSelect.appendChild(opt);
                }
                this.modelSelect.value = recommended;
                this.selectedModel = recommended;
              } else {
                this.selectedModel = recommended;
              }
            }
          }
        } catch (err) {
          console.warn("[YouTubeUrlModal] model recommendation failed", err);
        }
      }
      this.showProcessingState();
      this.setStepState(0, "active");
      this.updateProgress(20, "Validating YouTube URL...");
      await new Promise((resolve) => setTimeout(resolve, 500));
      this.setStepState(0, "complete");
      this.setStepState(1, "active");
      this.updateProgress(40, "Extracting video data...");
      await new Promise((resolve) => setTimeout(resolve, 500));
      this.setStepState(1, "complete");
      this.setStepState(2, "active");
      this.updateProgress(60, "Analyzing video content...");
      const customPrompt = this.format === "custom" ? (_a = this.customPromptInput) == null ? void 0 : _a.value : void 0;
      const filePath = await this.options.onProcess(;
        trimmedUrl,
        this.format,
        this.selectedProvider,
        this.selectedModel,
        customPrompt;
      );
      this.setStepState(2, "complete");
      this.setStepState(3, "active");
      this.updateProgress(80, "Generating note...");
      await new Promise((resolve) => setTimeout(resolve, 300));
      this.updateProgress(100, "Complete!");
      this.setStepState(3, "complete");
      this.processedFilePath = filePath;
      this.showCompletionState();
    } catch (error) {
      this.flagActiveStepAsError();
      this.showErrorState(error);
      ErrorHandler.handle(error, "YouTube URL processing");
    }
  }
  /**
   * Handle open file button click
   */
  async handleOpenFile() {
    if (this.processedFilePath && this.options.onOpenFile) {
      try {
        await this.options.onOpenFile(this.processedFilePath);
        this.close();
      } catch (error) {
        ErrorHandler.handle(error, "Opening file");
      }
    }
  }
  /**
   * Show processing state
   */
  showProcessingState() {
    this.isProcessing = true;
    this.setValidationMessage("Processing video. This may take a moment...", "info");
    this.resetProgressSteps();
    if (this.progressContainer) {
      this.progressContainer.style.display = "block";
    }
    if (this.urlInput) {
      this.urlInput.disabled = true;
    }
    if (this.processButton) {
      this.processButton.disabled = true;
      this.processButton.textContent = "Processing...";
    }
    if (this.openButton) {
      this.openButton.style.display = "none";
    }
    this.setUrlInputState("idle");
    this.updateQuickActionsState();
  }
  /**
   * Show completion state
   */
  showCompletionState() {
    this.isProcessing = false;
    if (this.progressContainer) {
      this.progressContainer.style.display = "none";
    }
    if (this.urlInput) {
      this.urlInput.disabled = false;
      this.urlInput.value = "";
      this.url = "";
    }
    if (this.processButton) {
      this.processButton.disabled = false;
      this.processButton.textContent = "Process Another";
      this.processButton.style.display = "inline-block";
      this.processButton.style.opacity = "1";
    }
    if (this.openButton) {
      this.openButton.style.display = "inline-block";
    }
    if (this.headerEl) {
      this.headerEl.textContent = "\u2705 Video Processed Successfully!";
    }
    this.setValidationMessage("Note saved to today's folder. You can open it now or process another video.", "success");
    this.focusUrlInput();
    this.updateQuickActionsState();
    this.setUrlInputState("idle");
  }
  /**
   * Show error state
   */
  showErrorState(error) {
    this.isProcessing = false;
    if (this.progressContainer) {
      this.progressContainer.style.display = "none";
    }
    if (this.urlInput) {
      this.urlInput.disabled = false;
    }
    if (this.processButton) {
      this.processButton.disabled = false;
      this.processButton.textContent = MESSAGES.MODALS.PROCESS;
      this.processButton.style.display = "inline-block";
    }
    if (this.openButton) {
      this.openButton.style.display = "none";
    }
    if (this.headerEl) {
      this.headerEl.textContent = "\u274C Processing Failed";
    }
    this.setValidationMessage(error.message, "error");
    this.updateQuickActionsState();
    this.setUrlInputState(this.url.trim().length > 0 ? "invalid" : "idle");
  }
  /**
   * Update progress bar and text
   */
  updateProgress(percent, text) {
    if (this.progressBar) {
      this.progressBar.style.width = `${percent}%`;
    }
    if (this.progressText) {
      this.progressText.textContent = text;
    }
  }
  /**
   * Set initial URL value
   */
  setUrl(url) {
    if (this.url.trim() === url.trim()) {
      console.debug("YouTubeUrlModal: setUrl called with same URL, preventing cycle");
      return;
    }
    this.url = url;
    if (this.urlInput) {
      this.urlInput.value = url;
      this.updateProcessButtonState();
      this.updateQuickActionsState();
      const trimmed = url.trim();
      if (trimmed.length === 0) {
        this.setUrlInputState("idle");
      } else {
        this.setUrlInputState(ValidationUtils.isValidYouTubeUrl(trimmed) ? "valid" : "invalid");
      }
    }
  }
  /**
   * Clean up resources when modal is closed
   */
  onClose() {
    if (this.validationTimer) {
      clearTimeout(this.validationTimer);
      this.validationTimer = void 0;
    }
    super.onClose();
  }
  /**
   * Get current URL value
   */
  getUrl() {
    return this.url;
  }
  resetProgressSteps() {
    this.currentStepIndex = 0;
    if (this.progressSteps.length === 0) {
      return;
    }
    this.progressSteps.forEach((step) => {
      step.element.textContent = `\u25CB ${step.label}`;
    });
  }
  setStepState(index, state) {
    const target = this.progressSteps[index];
    if (!target) {
      return;
    }
    const prefix = this.getStepPrefix(state);
    target.element.textContent = `${prefix} ${target.label}`;
    if (state === "active") {
      this.currentStepIndex = index;
    } else if (state === "complete" && this.currentStepIndex === index) {
      this.currentStepIndex = Math.min(index + 1, this.progressSteps.length - 1);
    }
  }
  flagActiveStepAsError() {
    if (this.progressSteps.length === 0) {
      return;
    }
    this.setStepState(this.currentStepIndex, "error");
  }
  getStepPrefix(state) {
    switch (state) {
      case "active":;
        return "\u25CF";
      case "complete":;
        return "\u2714";
      case "error":;
        return "\u26A0";
      default:;
        return "\u25CB";
    }
  }
  createInlineButton(container, label, onClick) {
    const button = container.createEl("button", { text: label });
    button.style.padding = "6px 12px";
    button.style.fontSize = "0.85rem";
    button.style.borderRadius = "6px";
    button.style.border = "1px solid var(--background-modifier-border)";
    button.style.backgroundColor = "var(--background-primary)";
    button.style.color = "var(--text-normal)";
    button.style.cursor = "pointer";
    button.style.transition = "background-color 0.2s ease";
    button.addEventListener("mouseenter", () => {
      button.style.backgroundColor = "var(--background-modifier-hover)";
    });
    button.addEventListener("mouseleave", () => {
      button.style.backgroundColor = "var(--background-primary)";
    });
    button.addEventListener("click", onClick);
    return button;
  }
  async handlePasteFromClipboard() {
    if (this.isProcessing) {
      return;
    }
    if (!navigator.clipboard || !navigator.clipboard.readText) {
      this.setValidationMessage("Clipboard access is not available in this environment.", "error");
      new import_obsidian4.Notice("Clipboard access is not available.");
      return;
    }
    try {
      const text = await navigator.clipboard.readText();
      if (!text) {
        this.setValidationMessage("Clipboard is empty. Copy a YouTube URL first.", "info");
        return;
      }
      const trimmed = text.trim();
      this.url = trimmed;
      if (this.urlInput) {
        this.urlInput.value = trimmed;
      }
      this.lastValidUrl = void 0;
      this.updateProcessButtonState();
      this.updateQuickActionsState();
      const isValid = ValidationUtils.isValidYouTubeUrl(trimmed);
      this.setValidationMessage(;
        isValid ? "Ready to process this video." : "Enter a valid YouTube video URL.",
        isValid ? "success" : "error";
      );
      this.setUrlInputState(isValid ? "valid" : "invalid");
      if (this.processButton && !this.isProcessing && isValid) {
        this.processButton.focus();
      } else {
        this.focusUrlInput();
      }
    } catch (error) {
      ErrorHandler.handle(error, "Reading clipboard", false);
      this.setValidationMessage("Could not read from clipboard. Paste manually instead.", "error");
      new import_obsidian4.Notice("Could not read from clipboard.");
    }
  }
  handleClearUrl() {
    if (this.isProcessing) {
      return;
    }
    this.url = "";
    if (this.urlInput) {
      this.urlInput.value = "";
    }
    this.lastValidUrl = void 0;
    this.updateProcessButtonState();
    this.updateQuickActionsState();
    this.setValidationMessage("Paste a YouTube link to begin processing.", "info");
    this.setUrlInputState("idle");
    this.focusUrlInput();
  }
  updateQuickActionsState() {
    const hasUrl = this.url.trim().length > 0;
    if (this.clearButton) {
      this.clearButton.disabled = !hasUrl || this.isProcessing;
      this.clearButton.style.opacity = this.clearButton.disabled ? "0.5" : "1";
    }
    if (this.pasteButton) {
      this.pasteButton.disabled = this.isProcessing;
      this.pasteButton.style.opacity = this.pasteButton.disabled ? "0.5" : "1";
    }
  }
  setUrlInputState(state) {
    if (!this.urlInput) {
      return;
    }
    let borderColor = "var(--background-modifier-border)";
    let boxShadow = "none";
    if (state === "valid") {
      borderColor = "var(--text-accent)";
      boxShadow = "0 0 0 1px var(--text-accent)";
    } else if (state === "invalid") {
      borderColor = "var(--text-error)";
      boxShadow = "0 0 0 1px var(--text-error)";
    }
    this.urlInput.style.borderColor = borderColor;
    this.urlInput.style.boxShadow = boxShadow;
  }
  setValidationMessage(message, type) {
    if (!this.validationMessage) {
      return;
    }
    this.validationMessage.textContent = message;
    let color = "var(--text-muted)";
    if (type === "error") {
      color = "var(--text-error)";
    } else if (type === "success") {
      color = "var(--text-accent)";
    } else {
      color = "var(--text-muted)";
    }
    this.validationMessage.style.color = color;
  }
  /**
   * Try to fetch a lightweight preview for the provided YouTube URL using oEmbed.
   */
  async maybeFetchPreview(url) {
    if (this.fetchInProgress)
      return;
    if (!url)
      return;
    if (this.lastValidUrl === url && this.thumbnailEl && this.thumbnailEl.style.display === "block") {
      return;
    }
    this.setFetchingState(true);
    try {
      const meta = await this.fetchVideoPreview(url);
      if (meta) {
        this.showPreview(meta);
      } else {
        this.clearPreview();
      }
    } catch (error) {
      this.clearPreview();
    } finally {
      this.setFetchingState(false);
    }
  }
  setFetchingState(isFetching) {
    var _a;
    this.fetchInProgress = isFetching;
    if (this.processButton) {
      this.processButton.disabled = isFetching || !((_a = this.lastValidResult) != null ? _a : false);
      this.processButton.style.opacity = this.processButton.disabled ? "0.5" : "1";
    }
    if (this.validationMessage) {
      if (isFetching)
        this.setValidationMessage("Fetching preview...", "info");
      else if (this.lastValidResult);
        this.setValidationMessage("Ready to process this video.", "success");
      else;
        this.setValidationMessage("Enter a valid YouTube video URL.", "error");
    }
  }
  async fetchVideoPreview(url) {
    try {
      const oembed = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
      const res = await fetch(oembed);
      if (!res.ok)
        return null;
      const data = await res.json();
      return {
        title: data.title || "",
        author: data.author_name || "",
        thumbnail: data.thumbnail_url || "";
      };
    } catch (error) {
      return null;
    }
  }
  showPreview(meta) {
    if (!this.thumbnailEl || !this.metadataContainer)
      return;
    if (meta.thumbnail) {
      this.thumbnailEl.src = meta.thumbnail;
      this.thumbnailEl.style.display = "block";
    } else {
      this.thumbnailEl.style.display = "none";
    }
    const titleEl = this.metadataContainer.querySelector(".yt-preview-title");
    const channelEl = this.metadataContainer.querySelector(".yt-preview-channel");
    if (titleEl) {
      titleEl.textContent = meta.title;
      titleEl.style.fontWeight = "600";
      titleEl.style.marginBottom = "4px";
    }
    if (channelEl) {
      channelEl.textContent = meta.author;
      channelEl.style.color = "var(--text-muted)";
      channelEl.style.fontSize = "0.85rem";
    }
    this.metadataContainer.style.display = "block";
  }
  clearPreview() {
    if (this.thumbnailEl) {
      this.thumbnailEl.src = "";
      this.thumbnailEl.style.display = "none";
    }
    if (this.metadataContainer) {
      const titleEl = this.metadataContainer.querySelector(".yt-preview-title");
      const channelEl = this.metadataContainer.querySelector(".yt-preview-channel");
      if (titleEl)
        titleEl.textContent = "";
      if (channelEl)
        channelEl.textContent = "";
      this.metadataContainer.style.display = "none";
    }
  }
};

// src/settings-tab.ts
var import_obsidian5 = require("obsidian");

// src/secure-config.ts
var SecureConfigService = class {
  constructor(settings) {
    this.settings = settings;
  }
  /**
   * Get API key with environment variable fallback
   */
  getApiKey(keyType) {
    if (this.settings.useEnvironmentVariables) {
      return this.getFromEnvironment(keyType);
    }
    return keyType === "gemini" ? this.settings.geminiApiKey : this.settings.groqApiKey;
  }
  /**
   * Get API key from environment variables
   */
  getFromEnvironment(keyType) {
    const prefix = this.settings.environmentPrefix || "YTC";
    const envVarName = `${prefix}_${keyType.toUpperCase()}_API_KEY`;
    return this.getSecureEnvVar(envVarName) || "";
  }
  /**
   * Secure environment variable access
   * Note: In Obsidian plugins, environment variables are limited
   * This method can be extended for server-side environments
   */
  getSecureEnvVar(varName) {
    if (typeof process !== "undefined" && process.env) {
      return process.env[varName];
    }
    return this.getFromSecureStorage(varName);
  }
  /**
   * Get from secure storage (implementation depends on environment)
   */
  getFromSecureStorage(varName) {
    return void 0;
  }
  /**
   * Validate configuration security
   */
  validateSecurityConfiguration() {
    const warnings = [];
    let isSecure = true;
    if (!this.settings.useEnvironmentVariables) {
      if (this.settings.geminiApiKey && this.settings.geminiApiKey.length > 0) {
        warnings.push("Gemini API key is stored directly in configuration. Consider using environment variables.");
        isSecure = false;
      }
      if (this.settings.groqApiKey && this.settings.groqApiKey.length > 0) {
        warnings.push("Groq API key is stored directly in configuration. Consider using environment variables.");
        isSecure = false;
      }
    }
    if (this.settings.geminiApiKey === "your-api-key-here" || this.settings.groqApiKey === "your-api-key-here") {
      warnings.push("Default placeholder API keys detected. Please set real API keys.");
      isSecure = false;
    }
    return { isSecure, warnings };
  }
  /**
   * Get configuration template for environment variables
   */
  getEnvironmentTemplate() {
    const prefix = this.settings.environmentPrefix || "YTC";
    return `# YouTubeClipper Environment Variables;
# Set these in your environment for secure API key management;

# Google Gemini API Key;
${prefix}_GEMINI_API_KEY=your_gemini_api_key_here;

# Groq API Key  ;
${prefix}_GROQ_API_KEY=your_groq_api_key_here;

# Usage:;
# 1. Set these variables in your shell profile (.bashrc, .zshrc, etc.);
# 2. Enable "Use Environment Variables" in plugin settings;
# 3. Restart Obsidian to pick up the new environment variables;
`;
  }
};

// src/performance.ts
var PERFORMANCE_PRESETS = {
  fast: {
    name: "Fast",
    description: "Maximum speed with optimized models and parallel processing. Best for quick summaries.",
    timeouts: {
      geminiTimeout: 15e3,
      groqTimeout: 1e4,
      metadataTimeout: 5e3;
    },
    enableParallel: true,
    preferMultimodal: false,
    modelStrategy: {
      briefFormat: "llama-3.1-8b-instant",
      executiveSummary: "llama-3.3-70b-versatile",
      detailedGuide: "gemini-2.0-flash-lite",
      fallbackModel: "llama-3.1-8b-instant";
    }
  },
  balanced: {
    name: "Balanced",
    description: "Balanced speed and quality with multimodal analysis for detailed content.",
    timeouts: {
      geminiTimeout: 3e4,
      groqTimeout: 2e4,
      metadataTimeout: 1e4;
    },
    enableParallel: true,
    preferMultimodal: true,
    modelStrategy: {
      briefFormat: "llama-3.1-8b-instant",
      executiveSummary: "gemini-2.0-flash-lite",
      detailedGuide: "gemini-2.5-flash",
      fallbackModel: "llama-3.3-70b-versatile";
    }
  },
  quality: {
    name: "Quality",
    description: "Maximum quality with comprehensive multimodal analysis. Slower but most detailed.",
    timeouts: {
      geminiTimeout: 6e4,
      groqTimeout: 3e4,
      metadataTimeout: 15e3;
    },
    enableParallel: false,
    preferMultimodal: true,
    modelStrategy: {
      briefFormat: "gemini-2.0-flash-lite",
      executiveSummary: "gemini-2.5-flash",
      detailedGuide: "gemini-2.5-pro",
      fallbackModel: "gemini-2.0-flash";
    }
  }
};
var MODEL_CHARACTERISTICS = {
  // Groq Models (Speed optimized)
  "llama-3.1-8b-instant": {
    speed: "fast",
    quality: "basic",
    multimodal: false,
    provider: "Groq",
    estimatedLatency: 2,
    maxTokens: 2e3;
  },
  "llama-3.3-70b-versatile": {
    speed: "fast",
    quality: "good",
    multimodal: false,
    provider: "Groq",
    estimatedLatency: 5,
    maxTokens: 4e3;
  },
  "llama-4-maverick-17b-128e-instruct": {
    speed: "fast",
    quality: "excellent",
    multimodal: false,
    provider: "Groq",
    estimatedLatency: 8,
    maxTokens: 4e3;
  },
  "llama-4-scout-17b-16e-instruct": {
    speed: "fast",
    quality: "good",
    multimodal: false,
    provider: "Groq",
    estimatedLatency: 6,
    maxTokens: 4e3;
  },
  // Gemini Flash Models (Balanced)
  "gemini-2.0-flash": {
    speed: "medium",
    quality: "good",
    multimodal: true,
    provider: "Google Gemini",
    estimatedLatency: 10,
    maxTokens: 4e3;
  },
  "gemini-2.0-flash-lite": {
    speed: "fast",
    quality: "good",
    multimodal: true,
    provider: "Google Gemini",
    estimatedLatency: 6,
    maxTokens: 3e3;
  },
  "gemini-2.5-flash": {
    speed: "medium",
    quality: "excellent",
    multimodal: true,
    provider: "Google Gemini",
    estimatedLatency: 12,
    maxTokens: 4e3;
  },
  "gemini-2.5-flash-lite": {
    speed: "fast",
    quality: "good",
    multimodal: true,
    provider: "Google Gemini",
    estimatedLatency: 8,
    maxTokens: 3e3;
  },
  // Gemini Pro Models (Quality optimized)
  "gemini-1.5-pro": {
    speed: "slow",
    quality: "excellent",
    multimodal: true,
    provider: "Google Gemini",
    estimatedLatency: 20,
    maxTokens: 4e3;
  },
  "gemini-2.0-pro": {
    speed: "slow",
    quality: "excellent",
    multimodal: true,
    provider: "Google Gemini",
    estimatedLatency: 25,
    maxTokens: 4e3;
  },
  "gemini-2.5-pro": {
    speed: "slow",
    quality: "excellent",
    multimodal: true,
    provider: "Google Gemini",
    estimatedLatency: 30,
    maxTokens: 4e3;
  },
  "gemini-2.5-pro-tts": {
    speed: "slow",
    quality: "excellent",
    multimodal: true,
    provider: "Google Gemini",
    estimatedLatency: 35,
    maxTokens: 4e3;
  }
};
var PerformanceOptimizer = class {
  static getOptimalModel(format, videoDuration, performanceMode = "balanced", availableModels = []) {
    const preset = PERFORMANCE_PRESETS[performanceMode] || PERFORMANCE_PRESETS.balanced;
    const strategy = preset.modelStrategy;
    let selectedModel = strategy.fallbackModel;
    switch (format) {
      case "brief":;
        selectedModel = strategy.briefFormat;
        break;
      case "executive-summary":;
        selectedModel = strategy.executiveSummary;
        break;
      case "detailed-guide":;
        selectedModel = strategy.detailedGuide;
        break;
    }
    if (videoDuration && videoDuration < 300 && performanceMode === "fast") {
      return "llama-3.1-8b-instant";
    }
    if (availableModels.includes(selectedModel)) {
      return selectedModel;
    }
    const characteristics = MODEL_CHARACTERISTICS[selectedModel];
    if (characteristics) {
      const alternatives = availableModels.filter((model) => {
        const alt = MODEL_CHARACTERISTICS[model];
        return alt && alt.provider === characteristics.provider && alt.multimodal === characteristics.multimodal;
      });
      if (alternatives.length > 0) {
        return alternatives.sort(;
          (a, b) => MODEL_CHARACTERISTICS[a].estimatedLatency - MODEL_CHARACTERISTICS[b].estimatedLatency;
        )[0];
      }
    }
    return strategy.fallbackModel;
  }
  static estimateProcessingTime(model, videoDuration, format = "detailed-guide") {
    const characteristics = MODEL_CHARACTERISTICS[model];
    if (!characteristics) {
      return { min: 15, max: 60, description: "Unknown model" };
    }
    let baseTime = characteristics.estimatedLatency;
    if (videoDuration) {
      baseTime += Math.min(videoDuration / 60, 30);
    }
    const formatMultipliers = {
      "brief": 0.5,
      "executive-summary": 0.8,
      "detailed-guide": 1.2,
      "custom": 1;
    };
    const adjustedTime = baseTime * (formatMultipliers[format] || 1);
    const min = Math.round(adjustedTime * 0.8);
    const max = Math.round(adjustedTime * 1.5);
    const speed = characteristics.speed;
    const description = speed === "fast" ? "Fast processing" : speed === "medium" ? "Standard processing" : "Comprehensive processing";
    return { min, max, description };
  }
  static getPerformanceRecommendations(currentMode, videoDuration, format = "detailed-guide") {
    if (!videoDuration || videoDuration < 180) {
      return {
        recommended: "fast",
        reason: "Short videos don't require extensive analysis",
        alternative: "balanced";
      };
    }
    if (format === "brief") {
      return {
        recommended: "fast",
        reason: "Brief format prioritizes speed over depth",
        alternative: "balanced";
      };
    }
    if (videoDuration > 1800) {
      return {
        recommended: "quality",
        reason: "Long videos benefit from comprehensive analysis",
        alternative: "balanced";
      };
    }
    return {
      recommended: "balanced",
      reason: "Good balance of speed and quality for most content",
      alternative: currentMode === "balanced" ? "fast" : "balanced";
    };
  }
};

// src/settings-tab.ts
var SETTINGS_CSS_CLASSES = {
  container: "ytc-settings-container",
  section: "ytc-settings-section",
  header: "ytc-settings-header",
  validation: "ytc-settings-validation";
};
var YouTubeSettingsTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, options) {
    super(app, options.plugin);
    this.options = options;
    this.validationErrors = [];
    this.settings = { ...options.plugin.settings };
    this.secureConfig = new SecureConfigService(this.settings);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass(SETTINGS_CSS_CLASSES.container);
    containerEl.setAttribute("data-plugin", "youtube-clipper");
    this.createHeader();
    this.createAPISettings();
    this.createPerformanceSettings();
    this.createSecuritySettings();
    this.createFileSettings();
    this.createValidationStatus();
    this.createUsageInstructions();
  }
  /**
   * Create header with version information
   */
  createHeader() {
    const headerEl = this.containerEl.createDiv(SETTINGS_CSS_CLASSES.header);
    headerEl.createEl("h2", { text: "YouTubeClipper Settings" });
    const versionEl = headerEl.createDiv("ytc-version-info");
    versionEl.createEl("span", {
      text: "v1.2.0 - Production Ready",
      cls: "ytc-version-badge";
    });
    const statusEl = headerEl.createDiv("ytc-status-info");
    const hasValidConfig = this.validateConfiguration();
    statusEl.createEl("span", {
      text: hasValidConfig ? "\u2705 Ready to use" : "\u26A0\uFE0F Configuration needed",
      cls: hasValidConfig ? "ytc-status-good" : "ytc-status-warning";
    });
    const docsEl = headerEl.createDiv("ytc-docs-link");
    docsEl.createEl("a", {
      text: "\u{1F4D6} View Documentation",
      href: "#",
      cls: "ytc-docs-button";
    }).addEventListener("click", (e) => {
      e.preventDefault();
      this.showDocumentation();
    });
  }
  /**
   * Validate entire configuration
   */
  validateConfiguration() {
    var _a, _b;
    const hasApiKey = ((_a = this.settings.geminiApiKey) == null ? void 0 : _a.trim()) || ((_b = this.settings.groqApiKey) == null ? void 0 : _b.trim());
    const hasValidPath = ValidationUtils.isValidPath(this.settings.outputPath);
    return Boolean(hasApiKey && hasValidPath);
  }
  /**
   * Show inline documentation
   */
  showDocumentation() {
    window.open("https://github.com/youtube-clipper/obsidian-plugin#readme", "_blank");
  }
  /**
  * Create API configuration settings
  */
  createAPISettings() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "API Configuration" });
    const securityNotice = containerEl.createDiv("ytc-security-notice");
    securityNotice.style.padding = "12px";
    securityNotice.style.marginBottom = "16px";
    securityNotice.style.backgroundColor = "var(--background-modifier-hover)";
    securityNotice.style.borderLeft = "4px solid var(--text-accent)";
    securityNotice.style.borderRadius = "4px";
    const noticeTitle = securityNotice.createEl("strong");
    noticeTitle.textContent = "\u{1F512} Security Notice: ";
    const noticeText = securityNotice.createEl("span");
    noticeText.textContent = "API keys are encrypted and stored securely by Obsidian. Never share your keys or commit them to version control.";
    noticeText.style.display = "block";
    noticeText.style.marginTop = "4px";
    noticeText.style.fontSize = "0.9em";
    noticeText.style.color = "var(--text-muted)";
    const geminiSetting = new import_obsidian5.Setting(containerEl).setName("Gemini API Key").setDesc("Your Google Gemini API key for content processing (password field - secured)").addText((text) => {
      const inputEl = text.setPlaceholder("sk-... (your key is encrypted)").setValue(this.settings.geminiApiKey || "").onChange(async (value) => {
        await this.updateSetting("geminiApiKey", value);
      }).inputEl;
      inputEl.type = "password";
      inputEl.style.fontFamily = "monospace";
      inputEl.style.letterSpacing = "0.1em";
      return text;
    });
    this.addKeyToggle(geminiSetting, this.settings.geminiApiKey);
    this.addKeyClearButton(geminiSetting, "geminiApiKey");
    const groqSetting = new import_obsidian5.Setting(containerEl).setName("Groq API Key").setDesc("Your Groq API key for fallback processing (password field - secured)").addText((text) => {
      const inputEl = text.setPlaceholder("gsk_... (your key is encrypted)").setValue(this.settings.groqApiKey || "").onChange(async (value) => {
        await this.updateSetting("groqApiKey", value);
      }).inputEl;
      inputEl.type = "password";
      inputEl.style.fontFamily = "monospace";
      inputEl.style.letterSpacing = "0.1em";
      return text;
    });
    this.addKeyToggle(groqSetting, this.settings.groqApiKey);
    this.addKeyClearButton(groqSetting, "groqApiKey");
    const testSection = containerEl.createDiv("ytc-test-connection");
    testSection.style.marginTop = "16px";
    testSection.style.paddingTop = "12px";
    testSection.style.borderTop = "1px solid var(--background-modifier-border)";
    new import_obsidian5.Setting(testSection).setName("Test API Connection").setDesc("Verify your API keys are valid").addButton((btn) => btn.setButtonText("Test Keys").onClick(async () => {
      btn.setDisabled(true);
      btn.setButtonText("Testing...");
      try {
        await this.testAPIKeys();
        btn.setButtonText("\u2713 Success!");
        setTimeout(() => {
          btn.setButtonText("Test Keys");
          btn.setDisabled(false);
        }, 2e3);
      } catch (error) {
        btn.setButtonText("\u2717 Failed");
        ErrorHandler.handle(error, "API key test failed", true);
        setTimeout(() => {
          btn.setButtonText("Test Keys");
          btn.setDisabled(false);
        }, 2e3);
      }
    }));
  }
  /**
   * Add show/hide toggle for sensitive API keys
   */
  addKeyToggle(setting, keyValue) {
    const toggleBtn = setting.addButton((btn) => btn.setButtonText("\u{1F441}\uFE0F Show").setTooltip("Toggle key visibility").onClick((e) => {
      const inputs = setting.settingEl.querySelectorAll('input[type="password"], input[type="text"]');
      if (inputs.length === 0)
        return;
      const input = inputs[0];
      const isPassword = input.type === "password";
      input.type = isPassword ? "text" : "password";
      btn.setButtonText(isPassword ? "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F Hide" : "\u{1F441}\uFE0F Show");
    }));
  }
  /**
   * Add clear button to remove API key
   */
  addKeyClearButton(setting, settingKey) {
    const clearBtn = setting.addButton((btn) => btn.setButtonText("\u{1F5D1}\uFE0F Clear").setTooltip("Remove this API key").onClick(async () => {
      const keyName = settingKey === "geminiApiKey" ? "Gemini" : "Groq";
      if (confirm(`Are you sure you want to clear the ${keyName} API key?`)) {
        await this.updateSetting(settingKey, "");
        this.display();
      }
    }));
  }
  /**
   * Test API keys for validity
   */
  async testAPIKeys() {
    const errors = [];
    if (this.settings.geminiApiKey) {
      try {
        const response = await fetch(;
          "https://generativelanguage.googleapis.com/v1beta/models?key=" + this.settings.geminiApiKey;
        );
        if (!response.ok) {
          errors.push(`Gemini API key invalid (${response.status})`);
        }
      } catch (error) {
        errors.push("Gemini API key test failed (network error)");
      }
    } else {
      errors.push("Gemini API key not configured");
    }
    if (errors.length > 0) {
      throw new Error(errors.join("\n"));
    }
  }
  /**
   * Create performance and speed settings
   */
  createPerformanceSettings() {
    var _a, _b;
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "Performance & Speed" });
    const currentMode = this.settings.performanceMode || "balanced";
    const preset = PERFORMANCE_PRESETS[currentMode];
    new import_obsidian5.Setting(containerEl).setName("Performance Mode").setDesc(`Current: ${preset.name} - ${preset.description}`).addDropdown((dropdown) => dropdown.addOption("fast", "\u26A1 Fast - Maximum speed").addOption("balanced", "\u2696\uFE0F Balanced - Speed & Quality").addOption("quality", "\u{1F3AF} Quality - Maximum analysis").setValue(currentMode).onChange(async (value) => {
      await this.updateSetting("performanceMode", value);
      this.display();
    }));
    new import_obsidian5.Setting(containerEl).setName("Parallel Processing").setDesc("Race multiple AI providers simultaneously for faster responses").addToggle((toggle) => toggle.setValue(this.settings.enableParallelProcessing).onChange(async (value) => {
      await this.updateSetting("enableParallelProcessing", value);
    }));
    new import_obsidian5.Setting(containerEl).setName("Multimodal Analysis").setDesc("Use video-aware models that can analyze both audio and visual content").addToggle((toggle) => toggle.setValue(this.settings.preferMultimodal).onChange(async (value) => {
      await this.updateSetting("preferMultimodal", value);
    }));
    const statusEl = containerEl.createDiv();
    statusEl.createEl("h4", { text: "Current Configuration" });
    const statusListEl = statusEl.createEl("ul");
    const statusItems = [;
      `Mode: ${preset.name}`,
      `Parallel Processing: ${this.settings.enableParallelProcessing ? "Enabled" : "Disabled"}`,
      `Multimodal: ${this.settings.preferMultimodal ? "Preferred" : "Standard"}`,
      `Gemini Timeout: ${((_a = this.settings.customTimeouts) == null ? void 0 : _a.geminiTimeout) || preset.timeouts.geminiTimeout}ms`,
      `Groq Timeout: ${((_b = this.settings.customTimeouts) == null ? void 0 : _b.groqTimeout) || preset.timeouts.groqTimeout}ms`;
    ];
    statusItems.forEach((item) => {
      const li = statusListEl.createEl("li");
      li.textContent = item;
    });
    const recommendations = PerformanceOptimizer.getPerformanceRecommendations(;
      this.settings.performanceMode,
      void 0,
      // video duration not available in settings
      "detailed-guide";
      // default format
    );
    const recEl = containerEl.createDiv();
    recEl.createEl("h4", { text: "Recommendations" });
    const recTextEl = recEl.createEl("p");
    recTextEl.textContent = recommendations.reason;
    recTextEl.style.fontStyle = "italic";
    recTextEl.style.color = "var(--text-muted)";
  }
  /**
   * Create security configuration settings
   */
  createSecuritySettings() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "Security Configuration" });
    new import_obsidian5.Setting(containerEl).setName("Use Environment Variables").setDesc("Load API keys from environment variables instead of storing them in configuration").addToggle((toggle) => toggle.setValue(this.settings.useEnvironmentVariables || false).onChange(async (value) => {
      await this.updateSetting("useEnvironmentVariables", value);
      this.display();
    }));
    if (this.settings.useEnvironmentVariables) {
      new import_obsidian5.Setting(containerEl).setName("Environment Variable Prefix").setDesc("Prefix for environment variable names (e.g., YTC_GEMINI_API_KEY)").addText((text) => text.setPlaceholder("YTC").setValue(this.settings.environmentPrefix || "YTC").onChange(async (value) => {
        await this.updateSetting("environmentPrefix", value || "YTC");
      }));
      const envTemplate = this.secureConfig.getEnvironmentTemplate();
      const envSection = containerEl.createDiv("ytc-env-template");
      envSection.createEl("h4", { text: "Environment Variables Template" });
      envSection.createEl("p", {
        text: "Copy these environment variables to your shell profile:",
        cls: "setting-item-description";
      });
      const preEl = envSection.createEl("pre");
      preEl.createEl("code", { text: envTemplate });
      new import_obsidian5.Setting(envSection).setName("Copy Template").setDesc("Copy the environment variables template to clipboard").addButton((button) => button.setButtonText("Copy to Clipboard").onClick(() => {
        navigator.clipboard.writeText(envTemplate);
        button.setButtonText("Copied!");
        setTimeout(() => button.setButtonText("Copy to Clipboard"), 2e3);
      }));
    }
    const validation = this.secureConfig.validateSecurityConfiguration();
    if (!validation.isSecure) {
      const warningEl = containerEl.createDiv("ytc-security-warnings");
      warningEl.createEl("h4", { text: "\u26A0\uFE0F Security Warnings", cls: "ytc-warning-header" });
      validation.warnings.forEach((warning) => {
        warningEl.createEl("p", { text: warning, cls: "ytc-warning-text" });
      });
    }
  }
  /**
   * Create file configuration settings
   */
  createFileSettings() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "File Configuration" });
    new import_obsidian5.Setting(containerEl).setName("Output Path").setDesc("Directory path where processed videos will be saved (relative to vault root)").addText((text) => text.setPlaceholder(MESSAGES.PLACEHOLDERS.OUTPUT_PATH).setValue(this.settings.outputPath).onChange(async (value) => {
      await this.updateSetting("outputPath", value);
    }));
  }
  /**
   * Create validation status display
   */
  createValidationStatus() {
    const { containerEl } = this;
    if (this.validationErrors.length > 0) {
      const errorSection = containerEl.createDiv();
      errorSection.style.marginTop = "20px";
      errorSection.style.padding = "10px";
      errorSection.style.backgroundColor = "var(--background-modifier-error)";
      errorSection.style.borderRadius = "4px";
      errorSection.createEl("h4", {
        text: "\u26A0\uFE0F Configuration Issues",
        attr: { style: "color: var(--text-error); margin-top: 0;" }
      });
      const errorList = errorSection.createEl("ul");
      this.validationErrors.forEach((error) => {
        errorList.createEl("li", { text: error });
      });
    } else {
      const successSection = containerEl.createDiv();
      successSection.style.marginTop = "20px";
      successSection.style.padding = "10px";
      successSection.style.backgroundColor = "var(--background-modifier-success)";
      successSection.style.borderRadius = "4px";
      successSection.createEl("h4", {
        text: "\u2705 Configuration Valid",
        attr: { style: "color: var(--text-success); margin-top: 0;" }
      });
    }
  }
  /**
   * Create usage instructions
   */
  createUsageInstructions() {
    const { containerEl } = this;
    containerEl.createEl("h3", { text: "Usage Instructions" });
    const instructions = containerEl.createDiv();
    instructions.innerHTML = `;
            <p><strong>How to use:</strong></p>;
            <ol>;
                <li>Set your Gemini or Groq API key above</li>;
                <li>Configure your preferred output directory</li>;
                <li>Click the video icon in the ribbon or use the command palette</li>;
                <li>Paste a YouTube URL and click Process</li>;
                <li>The plugin will analyze the video and create a structured note</li>;
            </ol>;

            <p><strong>API Key Information:</strong></p>;
            <ul>;
                <li><strong>Gemini API:</strong> Get your key from <a href="https://aistudio.google.com/app/apikey">Google AI Studio</a></li>;
                <li><strong>Groq API:</strong> Get your key from <a href="https://console.groq.com/keys">Groq Console</a></li>;
                <li>At least one API key is required for the plugin to function</li>;
            </ul>;

            <p><strong>Note:</strong> This plugin requires an active internet connection and a valid API key.</p>;
            <p><strong>Limitations:</strong> Due to CORS restrictions, full transcript extraction may be limited. The plugin works with available metadata and descriptions.</p>;
        `;
  }
  /**
   * Update a setting value
   */
  async updateSetting(key, value) {
    try {
      this.settings[key] = value;
      await this.validateAndSaveSettings();
    } catch (error) {
      ErrorHandler.handle(error, `Settings update for ${key}`);
    }
  }
  /**
   * Validate and save settings
   */
  async validateAndSaveSettings() {
    const validation = ValidationUtils.validateSettings(this.settings);
    this.validationErrors = validation.errors;
    if (validation.isValid) {
      await this.options.onSettingsChange(this.settings);
    }
    this.display();
  }
  /**
   * Get current settings
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * Update settings from external source
   */
  updateSettings(newSettings) {
    this.settings = { ...newSettings };
    this.display();
  }
};

// src/services/ai-service.ts
init_api();
var AIService = class {
  constructor(providers, settings) {
    this.providers = [];
    if (!providers || providers.length === 0) {
      throw new Error(MESSAGES.ERRORS.MISSING_API_KEYS);
    }
    this.providers = providers;
    this.settings = settings;
    this.applyPerformanceSettings();
  }
  /**
   * Apply performance settings to providers
   */
  applyPerformanceSettings() {
    const preset = PERFORMANCE_PRESETS[this.settings.performanceMode] || PERFORMANCE_PRESETS.balanced;
    const timeouts = this.settings.customTimeouts || preset.timeouts;
    this.providers.forEach((provider) => {
      if (provider.name === "Google Gemini" && provider.setTimeout) {
        provider.setTimeout(timeouts.geminiTimeout);
      } else if (provider.name === "Groq" && provider.setTimeout) {
        provider.setTimeout(timeouts.groqTimeout);
      }
    });
  }
  /**
   * Update settings and reapply performance configurations
   */
  updateSettings(newSettings) {
    this.settings = newSettings;
    this.applyPerformanceSettings();
  }
  /**
   * Return available model options for a provider name (from constants mapping)
   */
  getProviderModels(providerName) {
    const raw = PROVIDER_MODEL_OPTIONS[providerName] || [];
    return raw.map((r) => typeof r === "string" ? r : r && r.name ? r.name : String(r));
  }
  /**
   * Best-effort fetch of latest models for all providers by scraping known provider pages.
   * Returns a mapping providerName -> list of discovered models. Falls back to static mapping.
   */
  async fetchLatestModels() {
    const result = {};
    const providers = this.getProviderNames();
    for (const p of providers) {
      try {
        const models = await this.fetchLatestModelsForProvider(p);
        result[p] = models.length > 0 ? models : PROVIDER_MODEL_OPTIONS[p] ? PROVIDER_MODEL_OPTIONS[p].map((m) => typeof m === "string" ? m : m.name) : [];
      } catch (error) {
        result[p] = PROVIDER_MODEL_OPTIONS[p] ? PROVIDER_MODEL_OPTIONS[p].map((m) => typeof m === "string" ? m : m.name) : [];
      }
    }
    return result;
  }
  /**
   * Fetch latest models for a single provider (best-effort scraping).
   */
  async fetchLatestModelsForProvider(providerName) {
    const url = PROVIDER_MODEL_LIST_URLS[providerName];
    const regex = PROVIDER_MODEL_REGEX[providerName];
    if (!url || !regex) {
      return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
    }
    try {
      const resp = await fetch(url, { method: "GET" });
      if (!resp.ok) {
        return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
      }
      const text = await resp.text();
      const matches = text.match(regex) || [];
      const normalized = Array.from(new Set(matches.map((m) => m.toLowerCase())));
      return normalized;
    } catch (error) {
      return PROVIDER_MODEL_OPTIONS[providerName] ? PROVIDER_MODEL_OPTIONS[providerName].map((m) => typeof m === "string" ? m : m.name) : [];
    }
  }
  /**
   * Process prompt with fallback support (original sequential method)
   */
  async process(prompt) {
    if (!prompt || typeof prompt !== "string") {
      throw new Error("Valid prompt is required");
    }
    if (this.settings.enableParallelProcessing) {
      return this.processParallel(prompt);
    }
    return this.processSequential(prompt);
  }
  /**
   * Process prompt with sequential fallback (original method)
   */
  async processSequential(prompt) {
    let lastError = null;
    for (const provider of this.providers) {
      try {
        console.log(`Attempting to process with ${provider.name}...`);
        const content = await provider.process(prompt);
        if (content && content.trim().length > 0) {
          return {
            content,
            provider: provider.name,
            model: provider.model;
          };
        } else {
          throw new Error("Empty response from AI provider");
        }
      } catch (error) {
        lastError = error;
        console.warn(`${provider.name} failed:`, error);
        if (provider === this.providers[this.providers.length - 1]) {
          break;
        }
      }
    }
    const errorMessage = lastError ? MESSAGES.ERRORS.AI_PROCESSING(lastError.message) : "All AI providers failed to process the request";
    throw new Error(errorMessage);
  }
  /**
   * Process prompt with parallel provider racing for maximum speed
   */
  async processParallel(prompt) {
    console.log("Starting parallel provider racing...");
    const providerPromises = this.providers.map(async (provider) => {
      try {
        const content = await provider.processWithTimeout(prompt);
        if (content && content.trim().length > 0) {
          return {
            content,
            provider: provider.name,
            model: provider.model,
            success: true,
            responseTime: Date.now();
          };
        } else {
          throw new Error("Empty response from AI provider");
        }
      } catch (error) {
        console.warn(`${provider.name} failed in parallel race:`, error);
        return {
          error: error.message,
          provider: provider.name,
          model: provider.model,
          success: false,
          responseTime: Date.now();
        };
      }
    });
    const results = await Promise.allSettled(providerPromises);
    for (const result of results) {
      if (result.status === "fulfilled" && result.value.success) {
        console.log(`Parallel winner: ${result.value.provider} (${Date.now() - result.value.responseTime}ms)`);
        return {
          content: result.value.content,
          provider: result.value.provider,
          model: result.value.model;
        };
      }
    }
    const errors = results.filter((r) => r.status === "fulfilled" && !r.value.success).map((r) => r.value.error);
    const errorMessage = errors.length > 0 ? MESSAGES.ERRORS.AI_PROCESSING(errors.join("; ")) : "All AI providers failed to process the request";
    throw new Error(errorMessage);
  }
  /**
   * Process prompt using a specific provider name. Optionally override the model if supported.
   */
  async processWith(providerName, prompt, overrideModel) {
    const provider = this.providers.find((p) => p.name === providerName);
    if (!provider) {
      throw new Error(`AI provider not found: ${providerName}`);
    }
    try {
      if (overrideModel && typeof provider.setModel === "function") {
        provider.setModel(overrideModel);
      }
      const content = await provider.process(prompt);
      if (content && content.trim().length > 0) {
        return { content, provider: provider.name, model: provider.model };
      }
      throw new Error("Empty response from AI provider");
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.AI_PROCESSING(error.message));
    }
  }
  /**
   * Check if any providers are available
   */
  hasAvailableProviders() {
    return this.providers.length > 0;
  }
  /**
   * Get list of available provider names
   */
  getProviderNames() {
    return this.providers.map((p) => p.name);
  }
  /**
   * Add a new provider
   */
  addProvider(provider) {
    this.providers.push(provider);
  }
  /**
   * Remove a provider by name
   */
  removeProvider(providerName) {
    const index = this.providers.findIndex((p) => p.name === providerName);
    if (index !== -1) {
      this.providers.splice(index, 1);
      return true;
    }
    return false;
  }
};

// src/gemini.ts
init_api();

// src/base.ts
var BaseAIProvider = class {
  constructor(apiKey, initialModel, timeout) {
    this.apiKey = apiKey;
    this._timeout = 3e4;
    if (!apiKey) {
      throw new Error("API key is required for AI provider");
    }
    this._model = initialModel || "";
    if (timeout) {
      this._timeout = timeout;
    }
  }
  // Default 30s timeout
  get model() {
    return this._model;
  }
  get timeout() {
    return this._timeout;
  }
  setModel(model) {
    this._model = model;
  }
  setTimeout(timeout) {
    this._timeout = timeout;
  }
  /**
   * Process with timeout support
   */
  async processWithTimeout(prompt, customTimeout) {
    const timeoutMs = customTimeout || this._timeout;
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`${this.name} request timed out after ${timeoutMs}ms`));
      }, timeoutMs);
    });
    const processPromise = this.process(prompt);
    return Promise.race([processPromise, timeoutPromise]);
  }
  /**
   * Validate API response structure
   */
  validateResponse(response, requiredPath) {
    let current = response;
    for (const key of requiredPath) {
      if (!current || typeof current !== "object" || !(key in current)) {
        return false;
      }
      current = current[key];
    }
    return current !== null && current !== void 0;
  }
  /**
   * Handle API errors consistently
   */
  async handleAPIError(response) {
    return ErrorHandler.handleAPIError(response, this.name);
  }
};

// src/gemini.ts
var GeminiProvider = class extends BaseAIProvider {
  constructor(apiKey, model, timeout) {
    super(apiKey, model || AI_MODELS.GEMINI, timeout);
    this.name = "Google Gemini";
  }
  async process(prompt) {
    const response = await fetch(`${API_ENDPOINTS.GEMINI}?key=${this.apiKey}`, {
      method: "POST",
      headers: this.createHeaders(),
      body: JSON.stringify(this.createRequestBody(prompt));
    });
    if (response.status === 401) {
      throw new Error(MESSAGES.ERRORS.GEMINI_INVALID_KEY);
    }
    if (!response.ok) {
      await this.handleAPIError(response);
    }
    const data = await response.json();
    if (!this.validateResponse(data, ["candidates", "0", "content", "parts", "0", "text"])) {
      throw new Error("Invalid response format from Gemini API");
    }
    return this.extractContent(data);
  }
  createHeaders() {
    return {
      "Content-Type": "application/json";
    };
  }
  createRequestBody(prompt) {
    const normalizedPrompt = prompt.toLowerCase();
    const isVideoAnalysis = normalizedPrompt.includes("youtube video") || normalizedPrompt.includes("youtu.be/") || normalizedPrompt.includes("youtube.com/");
    const baseConfig = {
      contents: [{
        parts: [{ text: prompt }];
      }],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 4e3,
        // Increased for detailed guides
        candidateCount: 1;
      }
      // safetySettings: [
      //     {
      //         category: "HARM_CATEGORY_HARASSMENT",
      //         threshold: "BLOCK_MEDIUM_AND_ABOVE"
      //     },
      //     {
      //         category: "HARM_CATEGORY_HATE_SPEECH",
      //         threshold: "BLOCK_MEDIUM_AND_ABOVE"
      //     }
      // ]
    };
    if (isVideoAnalysis) {
      const providerModels = PROVIDER_MODEL_OPTIONS["Google Gemini"] || [];
      const currentModelName = String(this.model || "").toLowerCase();
      const matched = providerModels.find((m) => {
        const name = typeof m === "string" ? m : m && m.name ? m.name : "";
        return String(name).toLowerCase() === currentModelName;
      });
      const supportsAudioVideo = matched && matched.supportsAudioVideo === true;
      const videoConfig = {
        ...baseConfig,
        systemInstruction: {
          parts: [{
            text: `You are an expert video content analyzer. Provide comprehensive, multimodal analysis using:;
\u2022 AUDIO STREAM: Transcribe all spoken content, identify speakers, capture tone/emphasis/emotion;
\u2022 VIDEO STREAM: Analyze visual elements, text overlays, diagrams, slides, gestures, scene changes, and visual demonstrations;
\u2022 INTEGRATED INSIGHTS: Synthesize audio and visual data to provide complete understanding;

For best results:;
- Prioritize accuracy in transcription and speaker identification;
- Extract and explain key concepts shown visually;
- Note timing relationships between audio and visual elements;
- Identify visual cues that reinforce or clarify spoken content`;
          }];
        }
      };
      const gcsMatch = prompt.match(/(gs:\/\/[\w\-\.\/]+\.(?:mp4|mov|mkv|webm))/i);
      if (gcsMatch && gcsMatch[1]) {
        const gcsUri = gcsMatch[1];
        videoConfig.contents = videoConfig.contents || [];
        videoConfig.contents.push({
          parts: [{ fileData: { fileUri: gcsUri, mimeType: "video/mp4" } }];
        });
      }
      return videoConfig;
    }
    return baseConfig;
  }
  extractContent(response) {
    const content = response.candidates[0].content.parts[0].text;
    return content ? content.trim() : "";
  }
};

// src/groq.ts
init_api();
var GroqProvider = class extends BaseAIProvider {
  constructor(apiKey, model, timeout) {
    super(apiKey, model || AI_MODELS.GROQ, timeout);
    this.name = "Groq";
  }
  async process(prompt) {
    const response = await fetch(API_ENDPOINTS.GROQ, {
      method: "POST",
      headers: this.createHeaders(),
      body: JSON.stringify(this.createRequestBody(prompt));
    });
    if (response.status === 404) {
      throw new Error(MESSAGES.ERRORS.GROQ_MODEL_NOT_FOUND);
    }
    if (!response.ok) {
      await this.handleAPIError(response);
    }
    const data = await response.json();
    if (!this.validateResponse(data, ["choices", "0", "message"])) {
      throw new Error("Invalid response format from Groq API");
    }
    return this.extractContent(data);
  }
  createHeaders() {
    return {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${this.apiKey}`;
    };
  }
  createRequestBody(prompt) {
    return {
      model: this.model,
      messages: [;
        {
          role: "system",
          content: "You are an expert content analyzer specializing in extracting practical value and creating actionable guides from video content. Focus on clarity, practicality, and immediate implementability. Even with limited information, provide maximum value through structured analysis and practical recommendations.";
        },
        {
          role: "user",
          content: prompt;
        }
      ],
      max_tokens: API_LIMITS.MAX_TOKENS,
      temperature: API_LIMITS.TEMPERATURE;
    };
  }
  extractContent(response) {
    const content = response.choices[0].message.content;
    return content ? content.trim() : "";
  }
};

// src/video-data.ts
init_api();

// src/services/transcript-service.ts
init_api();
var YouTubeTranscriptService = class {
  // 1 hour
  constructor(cache) {
    this.cache = cache;
    this.transcriptTTL = 1e3 * 60 * 60;
  }
  /**
   * Extract transcript for a YouTube video
   */
  async getTranscript(videoId) {
    var _a, _b;
    if (!videoId) {
      throw new Error("Video ID is required");
    }
    const cacheKey = `transcript-${videoId}`;
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const transcript = await this.fetchTranscriptWithFallback(videoId);
      if (transcript) {
        (_b = this.cache) == null ? void 0 : _b.set(cacheKey, transcript, this.transcriptTTL);
        return transcript;
      }
      return null;
    } catch (error) {
      console.warn("Failed to fetch transcript:", error);
      return null;
    }
  }
  /**
   * Fetch transcript using multiple methods with fallback
   */
  async fetchTranscriptWithFallback(videoId) {
    try {
      const transcript = await this.fetchFromYouTubeAPI(videoId);
      if (transcript)
        return transcript;
    } catch (error) {
      console.debug("YouTube API method failed:", error);
    }
    try {
      const transcript = await this.scrapeTranscriptFromPage(videoId);
      if (transcript)
        return transcript;
    } catch (error) {
      console.debug("Page scraping method failed:", error);
    }
    try {
      const transcript = await this.fetchFromThirdParty(videoId);
      if (transcript)
        return transcript;
    } catch (error) {
      console.debug("Third-party method failed:", error);
    }
    return null;
  }
  /**
   * Method 1: Official YouTube transcript API
   */
  async fetchFromYouTubeAPI(videoId) {
    const url = `https://video.google.com/timedtext?lang=en&v=${videoId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Transcript API failed: ${response.status}`);
    }
    const xmlText = await response.text();
    return this.parseXMLTranscript(xmlText, videoId);
  }
  /**
   * Method 2: Scrape transcript from YouTube page
   */
  async scrapeTranscriptFromPage(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const proxyUrl = `${API_ENDPOINTS.CORS_PROXY}?url=${encodeURIComponent(videoUrl)}`;
    const response = await fetch(proxyUrl);
    if (!response.ok) {
      throw new Error("Failed to fetch video page");
    }
    const html = await response.text();
    const transcriptData = await this.extractTranscriptFromHTML(html);
    if (transcriptData) {
      return this.createTranscript(transcriptData, videoId, true);
    }
    return null;
  }
  /**
   * Method 3: Third-party transcript service (optional)
   */
  async fetchFromThirdParty(videoId) {
    return null;
  }
  /**
   * Parse XML transcript from YouTube API
   */
  parseXMLTranscript(xmlText, videoId) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlText, "text/xml");
    const textElements = xmlDoc.getElementsByTagName("text");
    const segments = [];
    let fullText = "";
    for (let i = 0; i < textElements.length; i++) {
      const element = textElements[i];
      const text = element.textContent || "";
      const start = parseFloat(element.getAttribute("start") || "0");
      const duration = parseFloat(element.getAttribute("dur") || "0");
      if (text.trim()) {
        segments.push({ text: text.trim(), start, duration });
        fullText += text.trim() + " ";
      }
    }
    return {
      segments,
      fullText: fullText.trim(),
      language: "en",
      autoGenerated: true;
    };
  }
  /**
   * Extract transcript data from YouTube page HTML
   */
  async extractTranscriptFromHTML(html) {
    const transcriptRegex = /"captions":\s*{[^}]*"playerCaptionsTracklistRenderer":\s*{[^}]*"captionTracks":\s*\[([^\]]+)\]/;
    const match = html.match(transcriptRegex);
    if (!match || !match[1]) {
      return null;
    }
    try {
      const captionTracksJson = match[1];
      const captionTracks = JSON.parse(`[${captionTracksJson}]`);
      const englishTrack = captionTracks.find(;
        (track) => {
          var _a;
          return track.languageCode === "en" || ((_a = track.languageCode) == null ? void 0 : _a.startsWith("en"));
        }
      );
      if (!englishTrack || !englishTrack.baseUrl) {
        return null;
      }
      return fetch(englishTrack.baseUrl).then((resp) => {
        if (!resp.ok)
          throw new Error("Failed to fetch caption track");
        return resp.text();
      }).then((xmlText) => this.parseXMLTranscript(xmlText, "").segments).catch((err) => {
        console.debug("Failed to fetch caption track:", err);
        return null;
      });
    } catch (error) {
      console.debug("Failed to parse transcript from HTML:", error);
      return null;
    }
  }
  /**
   * Create transcript object from segments
   */
  createTranscript(segments, videoId, autoGenerated = false) {
    if (!Array.isArray(segments)) {
      segments = [segments];
    }
    const normalizedSegments = segments.map((seg) => ({
      text: seg.text,
      start: seg.start,
      duration: seg.duration || 0;
    }));
    const fullText = normalizedSegments.map((seg) => seg.text).join(" ").trim();
    return {
      segments: normalizedSegments,
      fullText,
      language: "en",
      autoGenerated;
    };
  }
  /**
   * Get transcript summary for quick analysis
   */
  async getTranscriptSummary(videoId, maxLength = 2e3) {
    const transcript = await this.getTranscript(videoId);
    if (!transcript) {
      return null;
    }
    if (transcript.fullText.length <= maxLength) {
      return transcript.fullText;
    }
    const keySegments = transcript.segments.filter((seg) => seg.text.length > 20).slice(0, 10).map((seg) => seg.text).join(" ");
    return keySegments.length > maxLength ? keySegments.substring(0, maxLength) + "..." : keySegments;
  }
  /**
   * Extract key time-stamped moments from transcript
   */
  async extractKeyMoments(videoId, count = 5) {
    const transcript = await this.getTranscript(videoId);
    if (!transcript || transcript.segments.length === 0) {
      return null;
    }
    const meaningfulSegments = transcript.segments.filter((seg) => seg.text.length > 30);
    if (meaningfulSegments.length === 0) {
      return null;
    }
    const totalSegments = meaningfulSegments.length;
    const step = Math.max(1, Math.floor(totalSegments / count));
    const keyMoments = [];
    for (let i = 0; i < totalSegments && keyMoments.length < count; i += step) {
      const segment = meaningfulSegments[i];
      keyMoments.push({
        time: segment.start,
        text: segment.text;
      });
    }
    return keyMoments;
  }
  /**
   * Check if transcript is available for a video
   */
  async isTranscriptAvailable(videoId) {
    const transcript = await this.getTranscript(videoId);
    return transcript !== null && transcript.segments.length > 0;
  }
};

// src/video-data.ts
var YouTubeVideoService = class {
  constructor(cache) {
    this.cache = cache;
    this.metadataTTL = 1e3 * 60 * 30;
    // 30 minutes
    this.descriptionTTL = 1e3 * 60 * 30;
    this.transcriptService = new YouTubeTranscriptService(cache);
  }
  /**
   * Extract video ID from YouTube URL
   */
  extractVideoId(url) {
    return ValidationUtils.extractVideoId(url);
  }
  /**
   * Get video metadata and description
   */
  async getVideoData(videoId) {
    var _a, _b;
    if (!videoId) {
      throw new Error("Video ID is required");
    }
    const cacheKey = this.getCacheKey("video-data", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const metadata = await this.getVideoMetadata(videoId);
      const result = {
        title: metadata.title || "Unknown Title",
        description: metadata.description || "No description available",
        duration: metadata.duration,
        thumbnail: metadata.thumbnail,
        channelName: metadata.channelName;
      };
      if (result.duration && result.duration < 1800) {
        this.checkTranscriptAvailability(videoId).then((hasTranscript) => {
          var _a2;
          result.hasTranscript = hasTranscript;
          (_a2 = this.cache) == null ? void 0 : _a2.set(cacheKey, result, this.metadataTTL);
        });
      }
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, result, this.metadataTTL);
      return result;
    } catch (error) {
      throw ErrorHandler.createUserFriendlyError(;
        error,
        "fetch video data";
      );
    }
  }
  /**
   * Get video metadata using YouTube oEmbed API
   */
  async getVideoMetadata(videoId) {
    var _a, _b;
    const cacheKey = this.getCacheKey("metadata", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    const oembedUrl = `${API_ENDPOINTS.YOUTUBE_OEMBED}?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      const response = await fetch(oembedUrl, {
        headers: {
          "User-Agent": "Obsidian YoutubeClipper Plugin";
        },
        signal: controller.signal;
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        if (response.status === 400) {
          throw new Error(`Invalid YouTube video ID: ${videoId}. Please check the URL and try again.`);
        } else if (response.status === 404) {
          throw new Error(`YouTube video not found: ${videoId}. The video may be private, deleted, or the ID is incorrect.`);
        } else if (response.status === 403) {
          throw new Error(`Access denied to YouTube video: ${videoId}. The video may be private or restricted.`);
        } else {
          throw new Error(MESSAGES.ERRORS.FETCH_VIDEO_DATA(response.status));
        }
      }
      const data = await response.json();
      let enhancedData = {
        title: data.title || "Unknown Title",
        thumbnail: data.thumbnail_url,
        author_name: data.author_name;
      };
      try {
        const pageData = await this.scrapeAdditionalMetadata(videoId);
        enhancedData = { ...enhancedData, ...pageData };
      } catch (error) {
        console.debug("Could not scrape additional metadata:", error);
      }
      const metadata = {
        title: enhancedData.title,
        description: enhancedData.description,
        duration: enhancedData.duration,
        thumbnail: enhancedData.thumbnail,
        channelName: enhancedData.author_name;
      };
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, metadata, this.metadataTTL);
      return metadata;
    } catch (error) {
      if (error instanceof DOMException && error.name === "AbortError") {
        throw new Error("Request timed out. Please check your internet connection and try again.");
      } else if (error instanceof TypeError) {
        throw new Error(MESSAGES.ERRORS.NETWORK_ERROR);
      } else if (error instanceof Error && error.message.includes("JSON")) {
        throw new Error("Failed to parse YouTube response. The service may be temporarily unavailable.");
      }
      throw error;
    }
  }
  /**
   * Scrape additional metadata from YouTube page
   */
  async scrapeAdditionalMetadata(videoId) {
    try {
      const html = await this.fetchVideoPageHTML(videoId);
      const durationMatch = html.match(/"lengthSeconds":"(\d+)"/);
      const duration = durationMatch ? parseInt(durationMatch[1]) : void 0;
      const descriptionMatch = html.match(/"shortDescription":"([^"]+)"/);
      const description = descriptionMatch ? descriptionMatch[1].replace(/\\u0026/g, "&").replace(/\\n/g, "\n") : void 0;
      return { description, duration };
    } catch (error) {
      return {};
    }
  }
  /**
   * Check if transcript is available for this video
   */
  async checkTranscriptAvailability(videoId) {
    try {
      return await this.transcriptService.isTranscriptAvailable(videoId);
    } catch (error) {
      return false;
    }
  }
  /**
   * Get video description by scraping the YouTube page
   */
  async getVideoDescription(videoId) {
    var _a, _b, _c;
    const cacheKey = this.getCacheKey("description", videoId);
    const cached = (_a = this.cache) == null ? void 0 : _a.get(cacheKey);
    if (cached) {
      return cached;
    }
    try {
      const html = await this.fetchVideoPageHTML(videoId);
      const description = this.extractDescriptionFromHTML(html);
      (_b = this.cache) == null ? void 0 : _b.set(cacheKey, description, this.descriptionTTL);
      return description;
    } catch (error) {
      console.warn("Failed to scrape video page:", error);
      const fallback = MESSAGES.WARNINGS.EXTRACTION_FAILED;
      (_c = this.cache) == null ? void 0 : _c.set(cacheKey, fallback, this.descriptionTTL);
      return fallback;
    }
  }
  /**
   * Fetch YouTube page HTML using CORS proxy
   */
  async fetchVideoPageHTML(videoId) {
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const proxyUrl = `${API_ENDPOINTS.CORS_PROXY}?url=${encodeURIComponent(videoUrl)}`;
    const response = await fetch(proxyUrl);
    if (!response.ok) {
      throw new Error(MESSAGES.WARNINGS.CORS_RESTRICTIONS);
    }
    return response.text();
  }
  /**
   * Extract description from YouTube page HTML
   */
  extractDescriptionFromHTML(html) {
    const patterns = [;
      /"shortDescription":"([^"]*?)"/,
      /"description":{"simpleText":"([^"]*?)"}/,
      /<meta name="description" content="([^"]*?)">/,
      /<meta property="og:description" content="([^"]*?)">/;
    ];
    for (const pattern of patterns) {
      const match = html.match(pattern);
      if (match && match[1]) {
        const cleanedText = ValidationUtils.cleanText(match[1]);
        return ValidationUtils.truncateText(cleanedText, API_LIMITS.DESCRIPTION_MAX_LENGTH);
      }
    }
    return MESSAGES.WARNINGS.AUTO_EXTRACTION;
  }
  /**
   * Validate YouTube URL and extract video ID
   */
  validateAndExtractVideoId(url) {
    if (!ValidationUtils.isValidYouTubeUrl(url)) {
      throw new Error(MESSAGES.ERRORS.INVALID_URL);
    }
    const videoId = this.extractVideoId(url);
    if (!videoId) {
      throw new Error(MESSAGES.ERRORS.INVALID_URL);
    }
    return videoId;
  }
  getCacheKey(namespace, videoId) {
    return `youtube-video-service:${namespace}:${videoId}`;
  }
};

// src/obsidian-file.ts
var import_obsidian6 = require("obsidian");
init_api();

// src/file-conflict-modal.ts
init_base_modal();
var COPY_WARNING = "A note with this title already exists. Choose how to proceed.";
var FileConflictModal = class extends BaseModal {
  constructor(app, file) {
    super(app);
    this.file = file;
    this.decision = "cancel";
  }
  onOpen() {
    this.createHeader("Note Already Exists");
    this.createMessage(`${COPY_WARNING}

Existing note: ${this.file.path}`);
    this.createButtons();
  }
  openAndWait() {
    return new Promise((resolve) => {
      this.resolve = resolve;
      this.forceVisible();
      this.open();
    });
  }
  onClose() {
    if (this.resolve) {
      this.resolve(this.decision);
    }
    super.onClose();
  }
  createButtons() {
    const container = this.createButtonContainer();
    this.createButton(container, "Cancel", false, () => {
      this.closeWithDecision("cancel");
    });
    this.createButton(container, "Save as Numbered Copy", false, () => {
      this.closeWithDecision("new-name");
    });
    this.createButton(container, "Overwrite Existing", true, () => {
      this.closeWithDecision("overwrite");
    });
  }
  closeWithDecision(decision) {
    this.decision = decision;
    this.close();
  }
};

// src/obsidian-file.ts
var ObsidianFileService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Save content to a file in the vault
   */
  async saveToFile(title, content, outputPath) {
    try {
      const filename = this.createSafeFilename(title);
      const normalizedBase = this.normalizePath(outputPath);
      await this.ensureDirectoryExists(normalizedBase);
      const dailyFolder = this.getDailyFolderPath(normalizedBase);
      await this.ensureDirectoryExists(dailyFolder);
      const filePath = `${dailyFolder}/${filename}`;
      const finalPath = await this.handleFileConflicts(filePath, content);
      return finalPath;
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.SAVE_FILE(error.message));
    }
  }
  /**
   * Open a file with user confirmation
   */
  async openFileWithConfirmation(file) {
    await this.waitForFileCreation();
    try {
      const currentFile = this.app.vault.getAbstractFileByPath(file.path);
      if (!(currentFile instanceof import_obsidian6.TFile)) {
        throw new Error(MESSAGES.ERRORS.FILE_NOT_EXISTS);
      }
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(currentFile);
    } catch (error) {
      throw new Error(MESSAGES.ERRORS.COULD_NOT_OPEN(error.message));
    }
  }
  /**
   * Create a safe filename from title
   */
  createSafeFilename(title) {
    const sanitized = ValidationUtils.sanitizeFilename(title);
    return `${sanitized}.md`;
  }
  /**
   * Ensure the output directory exists
   */
  async ensureDirectoryExists(outputPath) {
    try {
      await this.app.vault.createFolder(outputPath);
    } catch (error) {
    }
  }
  getDailyFolderPath(basePath) {
    const trimmedBase = basePath.replace(/\/+$/, "");
    const today = new Date().toISOString().split("T")[0];
    return `${trimmedBase}/${today}`;
  }
  /**
   * Handle file naming conflicts by adding timestamp
   */
  async handleFileConflicts(filePath, content) {
    const existingFile = this.app.vault.getAbstractFileByPath(filePath);
    if (existingFile instanceof import_obsidian6.TFile) {
      const decision = await this.promptConflictResolution(existingFile);
      switch (decision) {
        case "overwrite":;
          await this.app.vault.modify(existingFile, content);
          return existingFile.path;
        case "new-name":;
          return this.createVersionedCopy(existingFile.path, content);
        default:;
          throw new Error("Save cancelled by user");
      }
    }
    await this.app.vault.create(filePath, content);
    return filePath;
  }
  /**
   * Wait for file creation to complete
   */
  async waitForFileCreation() {
    return new Promise(;
      (resolve) => setTimeout(resolve, TIMEOUTS.FILE_CREATION_WAIT);
    );
  }
  /**
   * Get file by path with validation
   */
  getFileByPath(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    return file instanceof import_obsidian6.TFile ? file : null;
  }
  /**
   * Check if file exists at path
   */
  fileExists(filePath) {
    return this.getFileByPath(filePath) !== null;
  }
  /**
   * Create a file with unique naming
   */
  async createUniqueFile(basePath, content) {
    let counter = 1;
    let filePath = basePath;
    while (this.fileExists(filePath)) {
      const pathParts = basePath.split("/");
      const filename = pathParts.pop();
      const nameWithoutExt = filename.replace(".md", "");
      const newFilename = `${nameWithoutExt} (${counter}).md`;
      filePath = [...pathParts, newFilename].join("/");
      counter++;
    }
    await this.app.vault.create(filePath, content);
    return filePath;
  }
  async promptConflictResolution(file) {
    const modal = new FileConflictModal(this.app, file);
    const decision = await modal.openAndWait();
    return decision;
  }
  async createVersionedCopy(originalPath, content) {
    const pathParts = originalPath.split("/");
    const filename = pathParts.pop();
    const nameWithoutExt = filename.replace(".md", "");
    let counter = 1;
    let candidatePath;
    do {
      candidatePath = [...pathParts, `${nameWithoutExt} (${counter}).md`].join("/");
      counter++;
    } while (this.fileExists(candidatePath));
    await this.app.vault.create(candidatePath, content);
    return candidatePath;
  }
  normalizePath(path) {
    if (!path) {
      return "";
    }
    let normalized = path.trim();
    if (normalized.startsWith("./")) {
      normalized = normalized.slice(2);
    }
    while (normalized.startsWith("/")) {
      normalized = normalized.slice(1);
    }
    normalized = normalized.replace(/\/+/g, "/");
    return normalized;
  }
};

// src/services/prompt-service.ts
var _AIPromptService = class {
  /**
   * Create analysis prompt for YouTube video content with performance optimization
   */
  createAnalysisPrompt(videoData, videoUrl, format = "detailed-guide", customPrompt, performanceMode = "balanced") {
    if (customPrompt && customPrompt.trim()) {
      return this.applyCustomPrompt(customPrompt, videoData, videoUrl);
    }
    let baseTemplate;
    switch (performanceMode) {
      case "fast":;
        baseTemplate = _AIPromptService.COMPACT_BASE_TEMPLATE;
        break;
      case "quality":;
        baseTemplate = _AIPromptService.COMPREHENSIVE_BASE_TEMPLATE;
        break;
      default:;
        baseTemplate = _AIPromptService.BALANCED_BASE_TEMPLATE;
    }
    const baseContent = baseTemplate.replace("{{TITLE}}", videoData.title).replace("{{URL}}", videoUrl).replace("{{DESCRIPTION}}", videoData.description);
    switch (format) {
      case "executive-summary":;
        return this.createExecutiveSummaryPrompt(baseContent, videoUrl, performanceMode);
      case "brief":;
        return this.createBriefPrompt(baseContent, videoUrl, performanceMode);
      case "detailed-guide":;
      default:;
        return this.createDetailedGuidePrompt(baseContent, videoUrl, performanceMode);
    }
  }
  /**
   * Apply custom prompt template with placeholder substitution
   */
  applyCustomPrompt(customPrompt, videoData, videoUrl) {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return customPrompt.replace(/__VIDEO_TITLE__/g, videoData.title).replace(/__VIDEO_DESCRIPTION__/g, videoData.description).replace(/__VIDEO_URL__/g, videoUrl).replace(/__VIDEO_ID__/g, videoId || "unknown").replace(/__EMBED_URL__/g, embedUrl).replace(/__DATE__/g, new Date().toISOString().split("T")[0]).replace(/__TIMESTAMP__/g, new Date().toISOString());
  }
  /**
   * Create a brief prompt: short description plus resources list
   */
  createBriefPrompt(baseContent, videoUrl, performanceMode = "balanced") {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return `${baseContent}

        OUTPUT FORMAT - BRIEF DESCRIPTION + RESOURCES:;

        Use this EXACT template:;

        ---;
        title: {Video Title}
        source: ${videoUrl}
        created: "${new Date().toISOString().split("T")[0]}";
        modified: "${new Date().toISOString().split("T")[0]}";
        description: "One short paragraph (3-4 sentences) summarizing the video";
        type: youtube-note;
        format: brief;
        tags:;
          - youtube;
          - brief;
        status: processed;
        duration: "[Extract video duration]";
        channel: "[Extract channel name]";
        video_id: "${videoId || "unknown"}";
        processing_date: "${new Date().toISOString()}";
    ai_provider: "__AI_PROVIDER__";
    ai_model: "__AI_MODEL__";
        ---;

        <iframe width="640" height="360" src="${embedUrl}" title="{Video Title}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>;

        ---;

        ## Brief Description;
        [Provide a concise 3-4 sentence description that captures the core message of the video];

        ## Key Takeaways;
        - **[Takeaway 1]**: [Core insight or lesson from the video];
        - **[Takeaway 2]**: [Core insight or lesson from the video];
        - **[Takeaway 3]**: [Core insight or lesson from the video];

        ## Quick Actions;
        1. **[Immediate Action]**: [Specific action you can take right away];
        2. **[Next Step]**: [Follow-up action to apply what you learned];

        ## Resources;
        - **Original Video:** [Watch on YouTube](${videoUrl});
        - **Channel:** [Creator's Channel](https://youtube.com/channel/[extract-channel-id]);
        - **Top resources mentioned or related (links):**;
          - [Resource 1];
          - [Resource 2];
          - [Resource 3];

        IMPORTANT: Keep the Brief Description short and focused. Provide 2-3 high-quality resource links that help the reader explore the topic further. Action items should be simple and immediately applicable.`;
  }
  /**
   * Create executive summary prompt (250 words)
   */
  createExecutiveSummaryPrompt(baseContent, videoUrl, performanceMode = "balanced") {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return `${baseContent}

        OUTPUT FORMAT - EXECUTIVE SUMMARY:;

        Use this EXACT template:;

        ---;
        title: {Video Title}
        source: ${videoUrl}
        created: "${new Date().toISOString().split("T")[0]}";
        modified: "${new Date().toISOString().split("T")[0]}";
        description: "Single sentence capturing the core insight";
        type: youtube-note;
        format: executive-summary;
        tags:;
          - youtube;
          - executive-summary;
          - tag_1;
          - tag_2;
          - tag_3;
        status: processed;
        duration: "[Extract video duration]";
        channel: "[Extract channel name]";
        video_id: "${videoId || "unknown"}";
        processing_date: "${new Date().toISOString()}";
        word_count: 250;
    ai_provider: "__AI_PROVIDER__";
    ai_model: "__AI_MODEL__";
        ---;

        <iframe width="640" height="360" src="${embedUrl}" title="{Video Title}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>;

        ---;

        ## Executive Summary;
        [Provide a comprehensive executive summary in exactly 250 words or fewer. Focus on strategic insights, business implications, and high-level takeaways. Structure it as follows:;

        **First Paragraph:** Core problem/opportunity and the video's main thesis
        **Second Paragraph:** Key strategic insights and competitive advantages
        **Third Paragraph:** Business implications and recommendation priority

        Focus on strategic value, not tactical details. Make every word count.];

        ## Key Insights;
        - **[Strategic Insight 1]:** [Critical insight with business impact and specific example from video];
        - **[Strategic Insight 2]:** [Critical insight with business impact and specific example from video];
        - **[Strategic Insight 3]:** [Critical insight with business impact and specific example from video];

        ## Action Items (3-5 items);
        1. **[Immediate Priority - 0-30 days]**: [Specific, measurable action with clear success criteria];
        2. **[Short-term Priority - 1-3 months]**: [Specific, measurable action with clear success criteria];
        3. **[Strategic Priority - 3-6 months]**: [Specific, measurable action with clear success criteria];
        4. **[Long-term Priority - 6+ months]**: [Specific, measurable action with clear success criteria];
        5. **[Optional Additional Priority]**: [Specific, measurable action with clear success criteria];

        ## Resources;
        - **Original Video:** [Watch on YouTube](${videoUrl});
        - **Channel:** [Creator's Channel](https://youtube.com/channel/[extract-channel-id]);
        - **Key Tools/Frameworks:** [List main tools or frameworks mentioned];
        - **Official Documentation:** [Links to official docs for mentioned technologies];
        - **Further Reading:** [1-2 high-quality related articles or resources];

        CRITICAL:;
        - Keep the Executive Summary to exactly 250 words or fewer;
        - Provide 3-5 specific, actionable items with timeframes and success criteria;
        - Each action item should be measurable and directly tied to video content;
        - Focus on strategic business value, not just technical details`;
  }
  /**
   * Create detailed guide prompt
   */
  createDetailedGuidePrompt(baseContent, videoUrl, performanceMode = "balanced") {
    const videoId = ValidationUtils.extractVideoId(videoUrl);
    const embedUrl = videoId ? `https://www.youtube-nocookie.com/embed/${videoId}` : videoUrl;
    return `${baseContent}

        OUTPUT FORMAT - COMPREHENSIVE TUTORIAL:;

        Use this EXACT template:;

        ---;
        title: {Video Title}
        source: ${videoUrl}
        created: "${new Date().toISOString().split("T")[0]}";
        modified: "${new Date().toISOString().split("T")[0]}";
        description: "Single sentence capturing the core insight";
        type: youtube-note;
        format: detailed-tutorial;
        tags:;
          - youtube;
          - tutorial;
          - step-by-step;
          - tag_1;
          - tag_2;
          - tag_3;
        status: processed;
        duration: "[Extract video duration]";
        channel: "[Extract channel name]";
        video_id: "${videoId || "unknown"}";
        processing_date: "${new Date().toISOString()}";
        word_count: "[estimated word count]";
    ai_provider: "__AI_PROVIDER__";
    ai_model: "__AI_MODEL__";
        difficulty: "[beginner/intermediate/advanced]";
        estimated_time: "[time to complete]";
        ---;

        <iframe width="640" height="360" src="${embedUrl}" title="{Video Title}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>;

        ---;

        ## Comprehensive Tutorial;

        ### Concise Summary;

        [Two-part response: a concise summary under 150 words that captures the video's core value and main insights];

        ## Step-by-Step Implementation Guide;
        ### Step 1: [Action Title];
        - Detailed instruction 1;
        - Detailed instruction 2;
        - Key considerations or tips;

        ### Step 2: [Action Title];
        - Detailed instruction 1;
        - Detailed instruction 2;
        - Key considerations or tips;

        [Continue with additional steps as needed - provide comprehensive coverage];

        ## Action Items & Next Steps;
        ### Immediate Actions (0-1 week);
        - **[Action 1]**: [Specific, measurable task with clear success criteria];
        - **[Action 2]**: [Specific, measurable task with clear success criteria];
        - **[Action 3]**: [Specific, measurable task with clear success criteria];

        ### Short-term Goals (1-4 weeks);
        - **[Goal 1]**: [Specific outcome or milestone to achieve];
        - **[Goal 2]**: [Specific outcome or milestone to achieve];

        ### Long-term Objectives (1-3 months);
        - **[Objective 1]**: [Strategic objective with measurable results];
        - **[Objective 2]**: [Strategic objective with measurable results];

        ## Resources;
        - **Original Video:** [Watch on YouTube](${videoUrl});
        - **Channel:** [Creator's Channel](https://youtube.com/channel/[extract-channel-id]);
        - **Related Documentation:** [If any tools/frameworks mentioned, provide official docs links];
        - **Additional Learning:** [Suggest 2-3 related high-quality resources];
        - **Tools & Software:** [List any tools mentioned with download/setup links];
        - **Community:** [Relevant forums, Discord servers, or communities];

        IMPORTANT:;
        - Provide detailed, actionable steps that someone could follow to implement the concepts from the video;
        - Include 3-5 immediate action items and 2-4 longer-term goals;
        - Each action item should be specific, measurable, and directly tied to video content;
        - Success criteria should be clear and achievable`;
  }
  /**
   * Process AI response and inject provider information
   */
  processAIResponse(content, provider, model, format) {
    if (!content) {
      return content;
    }
    const providerValue = provider || "unknown";
    const modelValue = model || "unknown";
    let updatedContent = content.replace(/__AI_PROVIDER__/g, providerValue).replace(/__AI_MODEL__/g, modelValue);
    updatedContent = this.ensureFrontMatterValue(updatedContent, "ai_provider", providerValue);
    updatedContent = this.ensureFrontMatterValue(updatedContent, "ai_model", modelValue);
    return updatedContent;
  }
  ensureFrontMatterValue(content, key, value) {
    const pattern = new RegExp(`(${key}\\s*:\\s*)(["'])?([^"'\\n]*)(["'])?`, "i");
    if (pattern.test(content)) {
      return content.replace(pattern, (_, prefix, openingQuote, _existing, closingQuote) => {
        const quote = openingQuote || closingQuote ? '"' : "";
        return `${prefix}${quote}${value}${quote}`;
      });
    }
    if (content.startsWith("---")) {
      return content.replace(/^---\s*\n/, `---;
${key}: "${value}";
`);
    }
    return content;
  }
  /**
   * Create a summary prompt for shorter content
   */
  createSummaryPrompt(videoData, videoUrl) {
    return `Create a concise summary for this YouTube video:;

        Title: ${videoData.title}
        URL: ${videoUrl}
        Description: ${videoData.description}

        Please provide:;
        1. A 2-paragraph summary (max 250 words);
        2. 3-5 key takeaways;
        3. Main actionable insights;

        Format as markdown with clear headings.`;
  }
  /**
   * Validate prompt length and content
   */
  validatePrompt(prompt) {
    return Boolean(prompt) && typeof prompt === "string" && prompt.trim().length > 10 && prompt.length < 5e4;
  }
};
var AIPromptService = _AIPromptService;
// Optimized prompt templates for different performance modes
AIPromptService.COMPACT_BASE_TEMPLATE = `Analyze this YouTube video:;
Title: {{TITLE}}
URL: {{URL}}
Description: {{DESCRIPTION}}

Focus on extracting the key information and insights.`;
AIPromptService.BALANCED_BASE_TEMPLATE = `Analyze this YouTube video with multimodal analysis:;
Title: {{TITLE}}
URL: {{URL}}
Description: {{DESCRIPTION}}

Extract insights from both spoken content and visual elements, focusing on practical information.`;
AIPromptService.COMPREHENSIVE_BASE_TEMPLATE = `Analyze this YouTube video using comprehensive multimodal analysis:;
Title: {{TITLE}}
URL: {{URL}}
Description: {{DESCRIPTION}}

MULTIMODAL ANALYSIS INSTRUCTIONS:;
1. Watch the complete video using both audio and visual analysis capabilities;
2. Extract insights from spoken content, music, sound effects, and ambient audio;
3. Analyze visual elements including slides, diagrams, charts, body language, and demonstrations;
4. Focus on practical, action-oriented information with specific examples;
5. Maintain accuracy and cite specific examples from the video when relevant`;

// src/services/cache/memory-cache.ts
var MemoryCacheService = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.defaultTTL = 3e5;
    // 5 minutes
    this.lastCleanup = 0;
    this.CLEANUP_INTERVAL = 6e4;
  }
  // 1 minute
  /**
   * Get item from cache (optimized with lazy cleanup)
   */
  get(key) {
    var _a;
    if (this.cache.size > 50) {
      this.cleanup();
    }
    const item = this.cache.get(key);
    if (!item)
      return null;
    const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
    if (Date.now() - item.timestamp > ttl) {
      this.cache.delete(key);
      return null;
    }
    return item.data;
  }
  /**
   * Set item in cache
   */
  set(key, data, ttl) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl;
    });
  }
  /**
   * Clear all cache items
   */
  clear() {
    this.cache.clear();
  }
  /**
   * Delete specific cache item
   */
  delete(key) {
    return this.cache.delete(key);
  }
  /**
   * Check if key exists in cache
   */
  has(key) {
    var _a;
    const item = this.cache.get(key);
    if (!item) {
      return false;
    }
    const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
    if (Date.now() - item.timestamp > ttl) {
      this.cache.delete(key);
      return false;
    }
    return true;
  }
  /**
   * Get cache size
   */
  size() {
    return this.cache.size;
  }
  /**
   * Clean up expired items (optimized with batched operations)
   */
  cleanup() {
    var _a;
    const now = Date.now();
    if (now - this.lastCleanup < this.CLEANUP_INTERVAL)
      return;
    this.lastCleanup = now;
    const expiredKeys = [];
    for (const [key, item] of this.cache.entries()) {
      const ttl = (_a = item.ttl) != null ? _a : this.defaultTTL;
      if (now - item.timestamp > ttl) {
        expiredKeys.push(key);
      }
    }
    expiredKeys.forEach((key) => this.cache.delete(key));
  }
};

// src/services/service-container.ts
var ServiceContainer = class {
  constructor(settings, app) {
    this.settings = settings;
    this.app = app;
  }
  get aiService() {
    if (!this._aiService) {
      const providers = [];
      if (this.settings.geminiApiKey) {
        providers.push(new GeminiProvider(this.settings.geminiApiKey));
      }
      if (this.settings.groqApiKey) {
        providers.push(new GroqProvider(this.settings.groqApiKey));
      }
      this._aiService = new AIService(providers, this.settings);
    }
    return this._aiService;
  }
  get videoService() {
    if (!this._videoService) {
      this._videoService = new YouTubeVideoService(this.cacheService);
    }
    return this._videoService;
  }
  get fileService() {
    if (!this._fileService) {
      this._fileService = new ObsidianFileService(this.app);
    }
    return this._fileService;
  }
  get cacheService() {
    if (!this._cacheService) {
      this._cacheService = new MemoryCacheService();
    }
    return this._cacheService;
  }
  get promptService() {
    if (!this._promptService) {
      this._promptService = new AIPromptService();
    }
    return this._promptService;
  }
  /**
   * Update settings and refresh services that depend on them
   */
  async updateSettings(newSettings) {
    this.settings = newSettings;
    this._aiService = void 0;
  }
  /**
   * Clear all cached services
   */
  clearServices() {
    this._aiService = void 0;
    this._videoService = void 0;
    this._fileService = void 0;
    this._cacheService = void 0;
    this._promptService = void 0;
  }
};

// src/main.ts
var PLUGIN_PREFIX = "ytp";
var DEFAULT_SETTINGS = {
  geminiApiKey: "",
  groqApiKey: "",
  outputPath: "YouTube/Processed Videos",
  useEnvironmentVariables: false,
  environmentPrefix: "YTC",
  // Performance settings with smart defaults
  performanceMode: "balanced",
  enableParallelProcessing: true,
  preferMultimodal: true;
};
var YoutubeClipperPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.isUnloading = false;
    this.operationCount = 0;
    // Track temp notes we've already handled to avoid duplicate modal opens
    this.handledTempFiles = /* @__PURE__ */ new Set();
    // Track modal instances to prevent double opening
    this.isModalOpen = false;
  }
  async onload() {
    var _a;
    this.logInfo("Initializing YoutubeClipper Plugin v1.2.0...");
    const conflicts = ConflictPrevention.checkForPotentialConflicts();
    if (conflicts.length > 0) {
      this.logWarning(`Potential conflicts detected but proceeding: ${conflicts.join(", ")}`);
    }
    try {
      await this.loadSettings();
      await this.initializeServices();
      this.registerUIComponents();
      const NOTE_MARKER = "<!-- ytc-extension:youtube-clipper -->";
      const pendingUrls = /* @__PURE__ */ new Map();
      const URL_HANDLER_DELAY = 500;
      const isTempFile = (file, content) => {
        if (content && content.includes(NOTE_MARKER)) {
          return true;
        }
        if (file.name && file.name.startsWith("YouTube Clip -")) {
          return true;
        }
        const trimmedContent = content.trim();
        const lines = trimmedContent.split("\n").filter((line) => line.trim().length > 0);
        const isUrlOnly = lines.length === 1 && ValidationUtils.isValidYouTubeUrl(lines[0]);
        if (isUrlOnly && content.length < 200) {
          const fileAge = Date.now() - file.stat.ctime;
          const isInOutputPath = file.path.includes(this.settings.outputPath);
          if (fileAge < 5e3 && !isInOutputPath) {
            return true;
          }
        }
        return false;
      };
      const handleUrlSafely = (url, source, filePath, file, content) => {
        var _a2;
        console.log(`YouTubeClipper: ${source} - handleUrlSafely called for URL:`, url, "file:", filePath);
        if (file && content && !isTempFile(file, content)) {
          console.warn(`YouTubeClipper: ${source} - REJECTING URL in non-temp file: ${filePath}`);
          const fileAge = Date.now() - file.stat.ctime;
          const isInOutputPath = filePath == null ? void 0 : filePath.includes(this.settings.outputPath);
          const hasMarker = content.includes(NOTE_MARKER);
          const hasClipPrefix = (_a2 = file.name) == null ? void 0 : _a2.startsWith("YouTube Clip -");
          console.warn(`YouTubeClipper: ${source} - Rejection details: age=${fileAge}ms, inOutputPath=${isInOutputPath}, hasMarker=${hasMarker}, hasClipPrefix=${hasClipPrefix}`);
          return;
        }
        if (this.handledTempFiles.has(url)) {
          console.log(`YouTubeClipper: ${source} - URL already handled: ${url}, skipping`);
          return;
        }
        if (pendingUrls.has(url)) {
          console.log(`YouTubeClipper: ${source} - cancelling pending handler for URL:`, url);
          clearTimeout(pendingUrls.get(url));
        }
        this.handledTempFiles.add(url);
        if (filePath) {
          this.handledTempFiles.add(filePath);
        }
        console.log(`YouTubeClipper: ${source} - marked URL as handled:`, url);
        const timeout = setTimeout(() => {
          console.log(`YouTubeClipper: ${source} - DEBOUNCED: opening modal for URL: ${url}`);
          console.log(`YouTubeClipper: ${source} - pendingUrls size before:`, pendingUrls.size);
          console.log(`YouTubeClipper: ${source} - handledTempFiles size:`, this.handledTempFiles.size);
          void this.safeShowUrlModal(url);
          pendingUrls.delete(url);
          console.log(`YouTubeClipper: ${source} - pendingUrls size after:`, pendingUrls.size);
          if (this.handledTempFiles.size > 100) {
            const entries = Array.from(this.handledTempFiles);
            this.handledTempFiles.clear();
            entries.slice(-50).forEach((entry) => this.handledTempFiles.add(entry));
            console.log(`YouTubeClipper: ${source} - cleaned up handledTempFiles, new size:`, this.handledTempFiles.size);
          }
        }, URL_HANDLER_DELAY);
        pendingUrls.set(url, timeout);
        console.log(`YouTubeClipper: ${source} - set timeout for URL:`, url, "delay:", URL_HANDLER_DELAY);
      };
      this.registerEvent(this.app.vault.on("create", async (file) => {
        try {
          if (!(file instanceof import_obsidian7.TFile))
            return;
          const content = await this.app.vault.read(file);
          if (!isTempFile(file, content)) {
            console.debug("YouTubeClipper: create handler - ignoring existing file:", file.path);
            return;
          }
          let url = null;
          if (content && content.includes(NOTE_MARKER)) {
            url = content.replace(NOTE_MARKER, "").trim();
          } else {
            const maybe = (content || "").trim();
            const ytRegex = /(https?:\/\/(?:www\.)?youtube\.com\/watch\?v=[A-Za-z0-9_-]{6,}|https?:\/\/(?:www\.)?youtu\.be\/[A-Za-z0-9_-]{6,})/i;
            const m = maybe.match(ytRegex);
            if (m && m[1]) {
              url = m[1].trim();
            } else if (file.name && file.name.startsWith("YouTube Clip -")) {
              const single = maybe.split("\n").map((s) => s.trim()).find(Boolean) || "";
              if (ValidationUtils.isValidYouTubeUrl(single))
                url = single;
            }
          }
          if (!url) {
            console.debug("YouTubeClipper: create handler - no url extracted for temp file:", file.path);
            return;
          }
          console.log("YouTubeClipper: CREATE EVENT - detected temp note", { path: file.path, url });
          handleUrlSafely(url, "create-handler", file.path, file, content);
        } catch (e) {
        }
      }));
      this.registerEvent(this.app.workspace.on("active-leaf-change", async () => {
        try {
          const file = this.app.workspace.getActiveFile();
          if (!file || !(file instanceof import_obsidian7.TFile))
            return;
          if (this.handledTempFiles.has(file.path))
            return;
          const content = await this.app.vault.read(file);
          if (!isTempFile(file, content)) {
            console.debug("YouTubeClipper: active-leaf-change - ignoring existing file:", file.path);
            return;
          }
          let url = null;
          if (content && content.includes(NOTE_MARKER)) {
            url = content.replace(NOTE_MARKER, "").trim();
          } else {
            const maybe = (content || "").trim();
            const ytRegex = /(https?:\/\/(?:www\.)?youtube\.com\/watch\?v=[A-Za-z0-9_-]{6,}|https?:\/\/(?:www\.)?youtu\.be\/[A-Za-z0-9_-]{6,})/i;
            const m = maybe.match(ytRegex);
            if (m && m[1]) {
              url = m[1].trim();
            } else if (file.name && file.name.startsWith("YouTube Clip -")) {
              const single = maybe.split("\n").map((s) => s.trim()).find(Boolean) || "";
              if (ValidationUtils.isValidYouTubeUrl(single))
                url = single;
            }
          }
          if (!url) {
            console.debug("YouTubeClipper: active-leaf-change - no url for temp file:", file.path);
            return;
          }
          console.log("YouTubeClipper: ACTIVE-LEAF-CHANGE EVENT - detected temp note", { path: file.path, url });
          handleUrlSafely(url, "active-leaf-handler", file.path, file, content);
        } catch (e) {
        }
      }));
      this.logInfo("YoutubeClipper Plugin loaded successfully");
      try {
        (_a = this.registerObsidianProtocolHandler) == null ? void 0 : _a.call(this, "youtube-clipper", (params) => {
          try {
            const url = params.url || params.content || params.path || "";
            if (url && ValidationUtils.isValidYouTubeUrl(url)) {
              setTimeout(() => {
                void this.safeShowUrlModal(url);
              }, 200);
            } else {
              console.debug("YouTubeClipper: protocol handler received no valid url", params);
            }
          } catch (e) {
            console.warn("YouTubeClipper: protocol handler error", e);
          }
        });
      } catch (e) {
      }
    } catch (error) {
      this.logError("Failed to load plugin", error);
      ErrorHandler.handle(error, "Plugin initialization");
      new import_obsidian7.Notice("Failed to load YoutubeClipper Plugin. Check console for details.");
    }
  }
  onunload() {
    var _a;
    this.logInfo("Unloading YoutubeClipper Plugin...");
    this.isUnloading = true;
    try {
      this.isModalOpen = false;
      this.pendingModalUrl = void 0;
      (_a = this.serviceContainer) == null ? void 0 : _a.clearServices();
      this.cleanupUIElements();
      ConflictPrevention.cleanupAllElements();
      this.logInfo("YoutubeClipper Plugin unloaded successfully");
    } catch (error) {
      this.logError("Error during plugin unload", error);
    }
  }
  async initializeServices() {
    this.serviceContainer = new ServiceContainer(this.settings, this.app);
  }
  registerUIComponents() {
    this.ribbonIcon = this.addRibbonIcon("film", "Process YouTube Video", () => {
      void this.safeShowUrlModal();
    });
    console.log("YouTubeClipper: Ribbon icon set successfully");
    this.addCommand({
      id: `${PLUGIN_PREFIX}-process-youtube-video`,
      name: "Process YouTube Video",
      callback: () => {
        void this.safeShowUrlModal();
      }
    });
    this.addSettingTab(new YouTubeSettingsTab(this.app, {
      plugin: this,
      onSettingsChange: this.handleSettingsChange.bind(this);
    }));
    this.addCommand({
      id: `${PLUGIN_PREFIX}-open-url-from-clipboard`,
      name: "YouTube Clipper: Open URL Modal (from clipboard)",
      callback: async () => {
        try {
          let text = "";
          try {
            if (navigator && navigator.clipboard && navigator.clipboard.readText) {
              text = await navigator.clipboard.readText() || "";
            }
          } catch (e) {
            text = "";
          }
          if (text && ValidationUtils.isValidYouTubeUrl(text.trim())) {
            void this.safeShowUrlModal(text.trim());
            return;
          }
          const manual = window.prompt("Paste YouTube URL to open in YouTube Clipper:");
          if (manual && ValidationUtils.isValidYouTubeUrl(manual.trim())) {
            void this.safeShowUrlModal(manual.trim());
          } else {
            new import_obsidian7.Notice("No valid YouTube URL provided.");
          }
        } catch (error) {
          ErrorHandler.handle(error, "Open URL from clipboard");
        }
      }
    });
  }
  cleanupUIElements() {
    if (this.ribbonIcon) {
      this.ribbonIcon.remove();
      this.ribbonIcon = void 0;
    }
  }
  async safeShowUrlModal(initialUrl) {
    const callId = Math.random().toString(36).substr(2, 9);
    console.log(`YouTubeClipper [${callId}]: safeShowUrlModal called with URL:`, initialUrl);
    console.log(`YouTubeClipper [${callId}]: Current modal state - isModalOpen:`, this.isModalOpen, "pendingModalUrl:", this.pendingModalUrl);
    await this.safeOperation(async () => {
      if (this.isModalOpen) {
        console.warn(`YouTubeClipper [${callId}]: MODAL ALREADY OPEN - IGNORING request for:`, initialUrl);
        console.warn(`YouTubeClipper [${callId}]: Current pending URL:`, this.pendingModalUrl);
        if (initialUrl && initialUrl !== this.pendingModalUrl) {
          console.warn(`YouTubeClipper [${callId}]: Updating pending modal URL from:`, this.pendingModalUrl, "to:", initialUrl);
          this.pendingModalUrl = initialUrl;
        } else {
          console.warn(`YouTubeClipper [${callId}]: Same URL as pending, completely ignoring`);
        }
        return;
      }
      console.log(`YouTubeClipper [${callId}]: Setting isModalOpen = true for URL:`, initialUrl);
      this.isModalOpen = true;
      this.pendingModalUrl = initialUrl;
      console.log(`YouTubeClipper [${callId}]: About to open YouTubeUrlModal for URL:`, initialUrl);
      this.openYouTubeUrlModal(initialUrl);
      setTimeout(() => {
        console.log(`YouTubeClipper [${callId}]: Modal state after 100ms - isModalOpen:`, this.isModalOpen);
      }, 100);
    }, "Show URL Modal");
  }
  async safeOperation(operation, operationName) {
    if (this.isUnloading) {
      this.logWarning(`Attempted ${operationName} during plugin unload - skipping`);
      return null;
    }
    const opId = ++this.operationCount;
    this.logInfo(`Starting operation ${opId}: ${operationName}`);
    try {
      const result = await operation();
      this.logInfo(`Completed operation ${opId}: ${operationName}`);
      return result;
    } catch (error) {
      this.logError(`Failed operation ${opId}: ${operationName}`, error);
      ErrorHandler.handle(error, operationName);
      return null;
    }
  }
  openYouTubeUrlModal(initialUrl) {
    if (this.isUnloading) {
      ConflictPrevention.log("Plugin is unloading, ignoring modal request");
      return;
    }
    ConflictPrevention.safeOperation(async () => {
      var _a;
      const aiService = (_a = this.serviceContainer) == null ? void 0 : _a.aiService;
      const providers = aiService ? aiService.getProviderNames() : [];
      const modelOptionsMap = this.settings.modelOptionsCache || {};
      if (aiService && (!this.settings.modelOptionsCache || Object.keys(this.settings.modelOptionsCache).length === 0)) {
        for (const p of providers) {
          modelOptionsMap[p] = aiService.getProviderModels(p) || [];
        }
      }
      const modal = new YouTubeUrlModal(this.app, {
        onProcess: this.processYouTubeVideo.bind(this),
        onOpenFile: this.openFileByPath.bind(this),
        initialUrl,
        providers,
        modelOptions: modelOptionsMap,
        fetchModels: async () => {
          try {
            const map = await this.serviceContainer.aiService.fetchLatestModels();
            this.settings.modelOptionsCache = map;
            await this.saveSettings();
            return map;
          } catch (error) {
            return modelOptionsMap;
          }
        }
      });
      modal.onClose = () => {
        try {
          console.log(`YouTubeClipper: Modal onClose triggered for URL:`, initialUrl);
          console.log(`YouTubeClipper: Modal state before close - isModalOpen:`, this.isModalOpen, "pendingModalUrl:", this.pendingModalUrl);
          this.isModalOpen = false;
          this.pendingModalUrl = void 0;
          console.log(`YouTubeClipper: Modal state after close - isModalOpen:`, this.isModalOpen, "pendingModalUrl:", this.pendingModalUrl);
        } catch (error) {
          console.warn("YouTubeClipper: Error resetting modal state:", error);
          this.isModalOpen = false;
          this.pendingModalUrl = void 0;
          console.log(`YouTubeClipper: Force reset modal state after error - isModalOpen:`, this.isModalOpen);
        }
      };
      setTimeout(() => {
        if (this.isModalOpen && this.pendingModalUrl === initialUrl) {
          console.warn("YouTubeClipper: Fallback modal state reset triggered for URL:", initialUrl);
          this.isModalOpen = false;
          this.pendingModalUrl = void 0;
          console.log("YouTubeClipper: Modal state after fallback reset - isModalOpen:", this.isModalOpen);
        }
      }, 1e4);
      modal.open();
    }, "YouTube URL Modal").catch((error) => {
      ErrorHandler.handle(error, "Opening YouTube URL modal");
    });
  }
  async processYouTubeVideo(url, format = "detailed-guide", providerName, model, customPrompt) {
    if (this.isUnloading) {
      ConflictPrevention.log("Plugin is unloading, cancelling video processing");
      throw new Error("Plugin is shutting down");
    }
    const result = await ConflictPrevention.safeOperation(async () => {
      var _a;
      new import_obsidian7.Notice(MESSAGES.PROCESSING);
      const validation = ValidationUtils.validateSettings(this.settings);
      if (!validation.isValid) {
        throw new Error(`Configuration invalid: ${validation.errors.join(", ")}`);
      }
      const youtubeService = this.serviceContainer.videoService;
      const aiService = this.serviceContainer.aiService;
      const fileService = this.serviceContainer.fileService;
      const promptService = this.serviceContainer.promptService;
      const videoId = youtubeService.extractVideoId(url);
      if (!videoId) {
        throw new Error(MESSAGES.ERRORS.VIDEO_ID_EXTRACTION);
      }
      const videoData = await youtubeService.getVideoData(videoId);
      let promptToUse;
      if (format === "custom") {
        promptToUse = customPrompt;
      } else {
        promptToUse = (_a = this.settings.customPrompts) == null ? void 0 : _a[format];
      }
      const prompt = promptService.createAnalysisPrompt(videoData, url, format, promptToUse);
      let aiResponse;
      if (providerName) {
        aiResponse = await aiService.processWith(providerName, prompt, model);
      } else {
        aiResponse = await aiService.process(prompt);
      }
      const formattedContent = promptService.processAIResponse(;
        aiResponse.content,
        aiResponse.provider,
        aiResponse.model,
        format,
        videoData,
        url;
      );
      const filePath = await fileService.saveToFile(;
        videoData.title,
        formattedContent,
        this.settings.outputPath;
      );
      new import_obsidian7.Notice(MESSAGES.SUCCESS(videoData.title));
      return filePath;
    }, "YouTube Video Processing");
    if (!result) {
      throw new Error("Failed to process YouTube video");
    }
    return result;
  }
  async openFileByPath(filePath) {
    try {
      await new Promise((resolve) => setTimeout(resolve, 300));
      const cleanPath = filePath.startsWith("/") ? filePath.substring(1) : filePath;
      const file = this.app.vault.getAbstractFileByPath(cleanPath);
      if (!file || !(file instanceof import_obsidian7.TFile)) {
        throw new Error(`File not found at path: ${cleanPath}`);
      }
      await this.openFileInNewTab(file);
    } catch (error) {
      ErrorHandler.handle(error, "Opening file by path");
      throw error;
    }
  }
  async openFileInNewTab(file) {
    try {
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.openFile(file);
      this.app.workspace.setActiveLeaf(leaf);
      new import_obsidian7.Notice(`\u{1F4C2} Opened: ${file.name}`);
    } catch (error) {
      try {
        const currentLeaf = this.app.workspace.getLeaf(false);
        await currentLeaf.openFile(file);
        new import_obsidian7.Notice(`\u{1F4C2} Opened: ${file.name}`);
      } catch (fallbackError) {
        ErrorHandler.handle(fallbackError, "Opening file in current tab");
        new import_obsidian7.Notice(`Note saved as "${file.name}" but could not auto-open. Please open manually.`);
      }
    }
  }
  showPersistentSaveConfirmation(file) {
    try {
      const modal = new SaveConfirmationModal(this.app, file, (shouldOpen) => {
        if (shouldOpen) {
          void this.openFileInNewTab(file);
        }
      });
      modal.open();
    } catch (error) {
      ErrorHandler.handle(error, "Showing save confirmation");
      new import_obsidian7.Notice(`File saved: ${file.name}. Click to open.`, 0).noticeEl.onclick = () => {
        void this.openFileInNewTab(file);
      };
    }
  }
  async handleSettingsChange(newSettings) {
    var _a;
    try {
      this.settings = { ...newSettings };
      await this.saveSettings();
      await ((_a = this.serviceContainer) == null ? void 0 : _a.updateSettings(this.settings));
    } catch (error) {
      ErrorHandler.handle(error, "Settings update");
      throw error;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getServiceContainer() {
    return this.serviceContainer;
  }
  logInfo(message) {
    ConflictPrevention.log(`[INFO] ${message}`);
  }
  logWarning(message) {
    ConflictPrevention.log(`[WARN] ${message}`, "warn");
  }
  logError(message, error) {
    ConflictPrevention.log(`[ERROR] ${message}: ${error.message}`, "error");
  }
};
